# 1 介绍
使用HTTP协议的应用程序的性能和使用的传输层协议有关。

请求并发可以减少延迟和提高应用程序的性能。在一个TCP连接上，HTTP/1.0协议只允许有一个请求。HTTP/1.1协议增加了长连接，一定程度上实现了请求并发，但仍然有对头阻塞的问题。因此HTTP/1.0和HTTP/1.1协议中，客户端必须要建立多个连接实现请求并发。

另外，HTTP中的请求头和响应头的内容经常重复和冗长，这些不必要的网络流量使得TCP的传输窗口很快变满，同时加剧了当多个请求在一个TCP连接上传输时的延迟。

HTTP/2协议通过定义一个HTTP语义到底层连接的映射来解决这些问题，尤其是该协议允许在一个TCP连接上，交错发送多个请求的经过编码后的头域。该协议还支持设置请求的优先级，高优先级的请求可以更快的到达服务端。

和HTTP/1.1相比，HTTP/2使用更少的TCP连接，对网络更加友好。这意味着与其他TCP连接上的流量的竞争更少，连接寿命更长，从而更好地利用可用网络容量。然而，HTTP/2没有解决对头阻塞的问题。

最后，HTTP/2协议使用了更高效的二进制方式传输请求和响应。

# 2 HTTP/2协议概览
HTTP/2优化了HTTP语义的传输，支持HTTP的所有核心特性，但旨在比HTTP/1.1更高效。

HTTP/2运行在TCP连接上，是面向连接的应用层协议，客户端（client）是TCP连接的发起者（initiator）。

HTTP/2中基本的协议单位是帧（frame）（第4.1节），不同的帧类型对应不同的目的。例如，HEADERS和DATA类型的帧组成了HTTP请求和响应（第8.1节），其他帧类型，如SETTINGS、WINDOW_UPDATE和PUSH_PROMISE，用于实现HTTP/2的其他特性。

通过HTTP请求和响应流（stream）（第5章）实现请求的多路复用，流在很大程度上是互相独立的，所以一个被阻塞或停滞的请求或响应不会影响其他流。

多路复用的高效建立在流的控制和优先级上。流控（第5.2节）是通过控制传输给接收方能够处理的数据量，优先级（第5.3节）保证有限的资源达到最大的利用率。当前HTTP/2修订版弃用了[RFC7540]中的优先级信令方案。

因为在一个TCP连接上传输的HTTP头域包含大量的冗余数据，而帧包含压缩后的头域信息（第4.3节），这对降低请求的大小产生了积极的影响，使得多个请求可以压缩在一个包（packet）里发送。

最后，HTTP/2增加了一个可选的交互模式，就是服务端可以推送响应给客户端（第8.4节），目的是允许服务端可以推测性的发送客户端需要的数据，在网络使用率和缩短延迟之间进行一种权衡。客户端发送一个PUSH_PROMISE帧请求，然后服务端在一个单独的流上发送响应给客户端。

## 2.1 文档组织
HTTP/2协议规范分为四部分
建立HTTP/2连接介绍HTTP/2中的连接初始化（第3章）
帧（第4章）和流（第5章）介绍HTTP/2的帧的结构以及如何组成多路复用的流
帧（第6章）和错误（第7章）定义了帧的详细信息以及错误类型
HTTP映射（第8章）和额外要求（第9章）介绍了使用帧和流是如何表达HTTP语义的

这里帧和流是根据HTTP协议量身定做的，不是普遍意义上的帧和流的概念。

## 2.2 惯例和术语
文档中出现的关键词必须/一定、必须不/一定不、要求、可能、可能不、应该、应该不、推荐、不推荐、可能、可选，按照BCP 14[RFC2119] [RFC8174]的解释。

所有出现的数字都是网络字节序，数值除非特别说明，否则都是无符号的，数值是十进制或者十六进制，如果是十六进制，会添加“0x”和十进制做区分。

文档中出现的二进制格式使用RFC9000中的第1.3节的约定来描述。

术语介绍：
客户端（client）：发起HTTP/2连接的端点，客户端发送HTTP请求，接收HTTP响应
服务端（server）：接收HTTP/2连接的端点，服务端接收HTTP请求，发送HTTP响应
连接（connection）：两个端点之间的传输层连接
连接错误（connection error）：影响HTTP/2连接的错误
端点（endpoint）：连接的客户端或者服务端
帧（frame）：HTTP连接上信息交流的最小单元，包括一个头部和一个变长的二进制序列，具体依据不同的帧类型而定
对端（peer）：一个端点，和正在讨论的端点相对的另一个端点
接收方（receiver）：正在接收帧的端点
发送方（sender）：正在发送帧的端点
流（stream）：HTTP/2连接上的双向流动的帧
流错误（stream error）：HTTP/2流上的一个错误

术语“网关”，“中间设备”，“代理服务器”和“隧道”在文档[RGFC9110]中的第3.7节定义。中间设备在不同时间承担客户端和服务端的角色。

# 3 建立HTTP/2的连接
发送HTTP请求之前需要首先知道服务端是否支持HTTP/2。

HTTP/2和HTTP/1.1一样，使用“http”和“https”URI以及使用相同的默认端口号，但是在URI中没有用于区分HTTP版本的信息。

HTTP/2协议对于“http”和“https”URI的支持是不同的。第3.2节描述HTTP/2协议对“https”URI的支持， 第3.3节描述HTTP/2协议对“http”URI的支持只能通过额外的已知信息获得。

## 3.1 识别HTTP/2版本
HTTP/2协议规范定义了两个标识符。

标识符“h2”标识使用传输层加密TLS协议的HTTP/2。这个标识符用于TLS ALPN中。
“h2”的ASCII取值为0x68和0x32

标识符“h2c”用于HTTP请求头头域“Upgrade”中，这个字段未被广泛使用，本文档中已经弃用。这个标识符还可用于HTTP请求头域“Settings”中，设置改字段取值为“h2c”，可以将请求升级到HTTP/2

## 3.2 使用“https”URI创建一个HTTP/2连接
一个客户端使用“https”URI发送请求需要使用TLS ALPN。该ALPN的取值为“h2”，一定不能是“h2c”。

一旦TLS协商完成，客户端和服务端都必须发送一个连接前言（connection preface）（第3.4节）。

## 3.3 已知服务端支持HTTP/2，创建一个HTTP/2连接
客户端可以通过其他方式，比如配置信息，知道服务端支持HTTP/2。

如果客户端知道服务端支持HTTP/2，可以先和服务端建立一个TCP连接，然后发送一个连接前言和HTTP/2帧。服务端可以根据连接前言识别HTTP/2连接。

同理，服务端也必须发生那个一个连接前言给客户端。

服务端对HTTP/2协议的支持不表示未来也支持HTTP/2协议，例如，服务器的配置可能会发生变化，集群实例的配置不同，网络条件也可能发生变化。

## 3.4 HTTP/2连接前言
在HTTP/2协议中，每个端点都必须发送一个连接前言确定使用的HTTP协议版本，以及初始化HTTP/2连接的设置。客户端和服务端发送不同的连接前言。

客户端的连接前言以24个字符开头，16进制格式如下：
0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a

转换为可读字符串是“PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n”。这个字符序列后面必须是一个可为空的SETTINGS帧（第6.5节）。客户端发送的连接前言是第一个应用层数据。

注意：使用客户端连接前言的目的是为了HTTP/1.1或HTTP/1.0服务器和中间设备不会处理后续的帧。需要注意的是这并不能解决【谈话】中提出的问题。

服务端连接前言包含可能为空的SETTINGS帧（第6.5节）也必须是服务端发送的第一个帧。

在发送完连接前言之后，收到的对端的连接前言之后的SETTINGS帧必须被当前端点处理。

为了避免不必要的延迟，客户端在发送完客户端前言之后，在收到服务端发送的服务端前言之前，允许立即发送其他的帧。需要注意的是，服务端发送的连接前言中的SETTINGS帧可能包含一些服务端希望客户端如何与其通信的设置信息。在客户端收到SETTINGS帧的时候，客户端可能已经发送了其他帧，此时客户端应该遵守发送其他帧时的设置。在有些配置中，服务端可以在客户端发送其他帧之前发送SETTINGS帧，避免客户端未按照服务端的配置要求发送其他帧。

客户端和服务端必须将一个无效的连接前言当做连接错误（第5.4.1节），错误类型为PROTOCOL_ERROR。在这种情况下，GOAWAY帧可以省略，应为已经知道对端不是使用HTTP/2协议。

# 4 HTTP帧
一旦HTTP/2连接建立，端点之间可以开始交换帧。

## 4.1 帧格式
所有的帧都有一个固定的9个字节的帧头和一个变长的帧体。

HTTP Frame {
    Length(24),
    Type(8),
    Flags(8),
    Reserved(1),
    Stream Identifier(32),
    Frame Payload(...),
}
图1：帧的构成

帧头中的字段定义如下：
长度（Length）：帧体的长度使用24位无符号的整数表示。帧体长度大于2^14（16,384）的值一定不能发送，除非接收方设置了一个更大的SETTINGS_MAX_FRAME_SIZE。

    该字段的取值不包含9个字节的帧头长度。

类型（Type）：帧类型使用8位表示。帧类型决定帧的格式和帧的语义。该文档中的第6节介绍帧，文档中未定义的帧类型必须忽视或者舍弃。

标识（Flags）：使用8位表示布尔类型的标识信息。该标识赋予帧类型一些特定的语义，未使用的标识，发生方将该值设置为0，接收方必须忽略这个标识信息。

保留（Reserved）：保留一位，这一位的语义未定义，发送方必须设置为0，接收方忽略这一位。

流标识（Stream Identifier）：流标识使用31位无符号整数表示（第5.1.1节）。值0被保留用作和整个连接相关联的帧，而不是单个流。

帧体的结构和内容完全取决于帧类型。

## 4.2 帧的大小
帧体的最大值受限于接收方通告的SETTINGS_MAX_FRAME_SIZE的大小，这个值的大小取值范围是闭区间[2^14,2^24-1]。

所有实现HTTP/2协议的实体必须支持收到2^14字节长度的帧体，以及9个字节长度的帧头。

提示：某些帧类型，如PING（第6.7节），对允许的帧体大小有额外的限制。

如果一个端点收到了一个超出SETTINGS_MAX_FRAME_SIZE大小的帧体，超出了任何帧类型的限制，或者太小以至于无法包含必须的帧内容，必须发送一个FRAME_SIZE_ERROR错误码。帧中可以修改整个连接状态的帧体大小类型的错误必须当做连接错误（第5.4.1节）处理，包括携带字段块（第5.4.1节）的帧（HEADERS，PUSH_PROMISE和CONTINUATION），一个SETTINGS帧，和任务流标识为0的帧。

端点发送的帧体的大小不一定是最大帧体大小，发送小于所允许的最大大小的帧可以提高帧的响应速度。发送大帧会造成对时间敏感的帧（比如RST STREAM，WINDOW_UPDATE，或PRIORITY）的发送延迟，如果传输被大帧阻塞了，可能会影响性能。

## 4.3 字段部分的压缩和解压缩
字段部分的压缩是将一组字段行（HTTP协议中的第5.2节）组成字段块的过程。字段部分的解压缩是将字段块解码成一组字段行的过程。HTTP/2中字段的压缩和解压缩详细定义在[COMPRESSION](https://datatracker.ietf.org/doc/html/rfc7541)文档中，处于某种历史原因，将这两个过程称作头部压缩和头部解压缩。

每一个字段块携带单个字段部分的所有压缩后的字段行。伪报头字段和包含控制信息的头部和字段行使用相同的格式。

提醒：RFC7540使用术语头部块代替更常用的字段块。

字段块携带请求、响应、承诺请求、推送响应的控制数据和头部部分。除PUSH_PROMISE（第6.6节）帧中包含的临时响应和请求外，所有这些消息都可以选择地包含一个携带尾部的字段块。

字段部分是字段行的集合。在一个字段部分中的每一个字段行包含一个单独的值。序列化后的字段块被分成一个或者多个二进制序列，叫做字段块段。第一个字段块段通过HEADERS或PUSH_PROMISE（第6.6节）类型的帧体传输，其他的字段块段通过CONTINUATION（第6.10节）类型的帧体传输。

头域Cookie在HTTP映射中被特殊处理（见8.2.3节）。

接收方点通过连接字段块段来重新组装字段块，然后解压缩该字段块获得字段部分。

一个完整的字段部分包括以下二者之一：
一个单独的HEADERS帧或PUSH_PROMISE帧，帧头上带有END_HEADERS标识
一个HEADERS帧或一个PUSH_PROMISE帧，帧头上带有END_HEADERS标识，并且包括一个或者多个CONTINUATION帧，最后一个CONTINUATION帧的帧头上带有END_HEADERS标识




每一个字段块进行离散处理。字段块必须通过连续的帧序列进行传输，不能交叉发送其他类型的帧或者其他流中的帧。HEADERS和CONTINUATION帧序列的最后一个帧设置END_HEADERS标识，PUSH_PROMISE和CONTINUATION帧序列的最后一个帧设置END_HEADERS标识。这样来看，逻辑上字段块等同于一个单独的帧。

字段块段只能作为HEADERS、PUSH_PROMISE或CONTINUATION帧的帧体进行发生发送，因为这些帧携带的数据可以修改接收方维护的压缩上下文。收到HEADERS、PUSH_PROMISE或CONTINUATION帧的端点需要重新组合收到的字段块，然后对其进行解压缩，即使收到的可能是需要丢弃的帧。如果接收方对字段块不进行解压缩，接收方必须以压缩错误类型的连接错误终止连接。

接收方对字段块进行解压缩时发生错误，必须将该错误当成压缩类型的连接错误。

### 4.3.1 压缩状态
字段压缩是有状态的。每个端点有一个HPACK编码器上下文和一个HPACK解码器上下文用于编码和解码连接上的所有字段块。[COMPRESSION](https://datatracker.ietf.org/doc/html/rfc7541)的第4节定义了一个动态表，记录了每个上下文中的基本状态。

动态表的大小是HPACK解码器设置的。HPACK解码器的上下文使用SETTINGS_HEADER_TABLE_SIZE设置动态表的大小，见第6.5.2节。连接建立之后，HPACK解码器和编码器按照SETTINGS_HEADER_TAGBLE_SIZE的初始值设置动态表的大小为4096。

对SETTINGS_HEADER_TABLE_SIZE的取值的修改需要在端点确认生效时候才可以生效（第6.5.3节）。HPACK编码器可以设置任何HPACK解码器设置的动态表的大小。HPACK编码器通过动态表大小变更指令声明动态表的大小。见[COMPRESSION](https://datatracker.ietf.org/doc/html/rfc7541)第6.3节。

一旦端点确认将SETTINGS_HEADER_TABLE_SIZE的大小设置为小于当前动态表的大小，HPACK编码器必须首先通过动态表大小更新指令声明动态表大小的变更，然后开始下一个字段块的编码。见[COMPRESSION](https://datatracker.ietf.org/doc/html/rfc7541)第4.2节。端点在确认动态表的大小变小之前，没有收到动态表的大小变更指令，将此时收到的字段块处理为压缩类型的连接错误（第5.4.1节）。

实现HTTP/2协议的实例，不建议通过交互的方式修改SETTINGS_HEADER_TABLE_SIZE的大小，建议使用连接前言设置小于初始值4096的值，但是这可能在某些实例中会失败。

# 5 流和多路复用
流是独立的，在HTTP/2连接上客户端和服务端之间双向流动的帧。流有几个重要的特征。

一个单独的HTTP/2连接上可以包含多个同时打开的流，多个流的帧可以交错流动。

流可以单方面建立，或者被其他端点共享

流可以被任一端点关闭

帧的发送顺序是非常重要的。接收方按照收到的帧的顺序处理帧，尤其HEADERS和DATA帧的顺序在语义上是非常重要的。

流通过一个整数进行区分。在端点初始化流的时候会为流分配一个流标识，通过流标识区分不同的流。

## 5.1 流的状态
流的声明周期如图2。
发送：端点发送帧
接收：端点接收帧
H：HEADERS帧（带有隐含的CONTINUATION帧）
ES：END_STREAM帧
R：RST_STREAM帧
PP：PUSH_PROMISE帧（带有隐含的CONTUNUATION帧）；状态转换用于承诺的流

图中展示了流的状态转换，并且可以看到只有帧和标识影响流的状态。可以看到CONTUNUATION帧并不会造成流状态的转换，他们只是会和HEADERS和PUSH_PROMISE帧一圈出现。帧携带的END_STREAM标识也会被当做流状态转换的一个时间。带有END_STREAM标识的HEADERS帧会造成两个状态转换。

在帧传输的过程中，两个端点对于流状态的转换有不同的主观视角。端点之间不互相协商创建流，而是单方面的创建流。在发送RST_STREAM帧之后，两个端点的流的closed状态会不匹配，因为RST_STREAM帧可能需要一些时间才会被接收方收到。

流有以下状态：
空闲（idle）：所有的流的初始状态都是空闲。

  空闲状态可以转换为以下状态：
    客户端发送或者服务端接收一个HEADERS帧，流的状态变成打开（open）。流标识在第5.1.1节描述。同样的HEADERS也可以造成流状态变成半关闭（half-closed）。
    发送PUSH_PROMISE帧流的状态变成保留状态（reserved local）。只有服务端会发送PUSH_PROMISE帧。
    接收PUSH_PROMISE帧之后流的状态变成保留状态（reserved remote）。只有客户端会收到PUSH_PROMISE帧。
    注意PUSH_PROMISE帧不是在空闲流上发送的，但是会携带另一个空闲流的Promised Stream ID信息。
    使用较大值的流标识符打开的流会造成标识符为较小值的流状态立即转换为关闭（closed）。这个状态转换未在图中展示。
  如果处于空闲状态的流收到除了HEADERS或PRIORITY帧之外的其他帧，必须将其视为协议错误类型的连接错误。如果是第5.1.1节介绍的服务端初始化的流，如果收到了HEADERS帧也必须将其视为协议错误类型的连接错误。可以发送或者接收PUSH_PROMISE帧呀

保留（本地）：发送PUSH_PROMISE帧之后，流状态成为保留（本地）状态。一个PUSH_PROMISE帧为一个被远端初始化的且是打开状态的流保留一个空闲流。
    
  保留（本地）状态有以下两种状态转换：
    端点发送HEADERS帧，流的状态变成半关闭（远端）状态
    任一端点发送RST_STREAM帧，流的状态变成关闭状态。这将释放流的保留状态。

  一个端点在保留（本地）状态一定不能发送除了HEADERS、RST_STREAM或PRIORITY类型的帧。

  在这个状态可能会收到PRIORITY或WINDOW_UPDATE帧，除了RST_STREAM、PRIORITY或WINDOW_UPDATE帧之外，收到其他类型的帧都必须当做协议错误类型的连接错误（第5.4.1节）。

保留（远端）：处于保留（远端）状态的流已经被远端预留。
  在这个状态，只有以下两种状态转换：
    收到HEADERS帧，流状态变为半关闭（本地）
    任一端点发送RST_STREAM帧，流状态变为关闭。这将释放流的保留状态。

  一个端点在保留（远端）状态一定不能发送除了RST_STREAM、WINDOW_UPDE或PRIORITY类型的帧。

  在这个状态收到除了HEADERS、 RST_STREAM或PRIORITY之外的其他类型的帧都必须当做协议错误类型的连接错误（第5.4.1节）。

打开（open）：两个端点可以在处于打开状态的流上发送任何类型的帧。在这种状态下，两个端点遵守流级的流量控制限制。

  处于该状态的每个端点都可以发送一个带有END_STREAM标识的帧，流的状态会从打开状态变为半关闭状态。发送END_STREAM标识的一端变为半关闭（本地）状态，接收END_STREAM标识的一端变为半关闭（远端）状态。

  处于该状态的每个端点都可以发送一个RST_STREAM帧，流的状态立即变为关闭状态。

半关闭（本地）：处于半关闭（本地）状态的流除了WINDOW_UPDATE、PRIORITY和RST_STREAM帧之外，不能发送其他类型的帧。

  如果接收方收到一个带有END_STREAM的帧或者收到/发送一个RST_STREAM，流的状态会变为关闭状态。

  处于该状态的端点可以接收任何类型的帧。提供WINDOW_UPDATE帧做为流量控制凭证对于持续收到流量控制的帧是必要的。在发送带有END_STREAM标识的帧之后进入该状态的端点可能会在一个短时间内收到一个WINDOW_UPDATE帧，此时该端点可以忽略WINDOW_UPDATE帧。

半关闭（远端）：如果一个流的状态是半关闭（远端）表示远端不会再发送帧。在这种状态下，一个端点不需要再维护一个接收方的流量控制窗口。

  如果一个端点收到除了WINDOW_UPDATE、PRIORITY或RST_STREAM类型之外的帧，必须响应一个流关闭类型的流错误。

  半关闭（远端）状态的流，端点可以发送任何类型的帧，端点需要持续关注发布流级的流量控制限制（第5.2节）。

  端点发送带有END_STREAM标识的帧会进入关闭状态，或者任何一端发送一个RST_STREAM帧。

关闭：关闭状态是终止状态。

  一个端点在发送并且收到一个带有END_STREAM标识的帧之后进入关闭状态。一个端点在发送和收到一个RST_STREAM帧之后也会进入关闭状态。
  
  在一个已经关闭的流上端点不能发送除了PRIORITY帧以外的其他帧，如果收到其他帧，除了端点可能会将其他帧视为流关闭类型的连接错误。

  一个端在在发送带有END_STREAM标识的帧或者RST_STREAM帧之后，可能会收到WINDOW_UPDATE或RST_STREAM帧，因为接收方在发送这两种帧的时候可能还没有收到带有END_STREAM标识的帧或者RST_STREAM帧。

  一个端点在一个处于打开或者半关闭（本地）状态的留上发送一个RST_STREAM帧之后可能会收到任何类型的帧。对端可能是在处理RST_STREAM帧之前已经发送或者已经将帧放入发送队列中。端点需要尽可能少的处理或者丢弃收到的这些帧。这意味着需要更新对HEADERS和PUSH_PROMISE帧的头部压缩状态。即使流处于关闭状态，也可能收到一个PUSH_PROMISE帧，将流的状态变为保留（对端）。另外，数据帧的内容也会计入连接的流量控制窗口。

  一个端点可以对处于关闭状态的流执行最小操作。端点可能会使用其他的信令检测对端是否已经收到导致流进入关闭状态的帧，这样可以正确的决定是否将收到了除了PRIORITY帧之外的其他帧当做协议错误类型的连接错误。端点可以使用携带对端已经收到了关闭信令信息的帧实现这个功能。端点不应该使用定时器实现这个功能。例如，端点在关闭流之后，可能会发送一个SETTINGS帧，在收到SETTINGS帧的响应之后，如果再收到其他DATA帧，端点可以认为这是一个错误。其他实现中可能会使用PING帧，在关闭流之后收到PING帧的响应，然后再收到流上的其他数据将其视为一个错误。

在没有更具体的规则说明下，实现HTTP/2协议的实例中，如果没有说明处于某种状态的流可以收到某种类型的帧，应该将其视为协议错误类型的连接错误。PRIORITY帧可以在任何状态的流中发送或者接收。

这部分的规则只适用于这个文档中定义的帧类型。收到语义未知的帧不能被当做错误，因为发送和接收这些帧的条件也是未知的。见第5.5节。

HTTP请求/响应的发送导致的流状态的转换示例见第8.8节。服务端推送数据的状态转换见第8.4.1节和第8.4.2节。

### 5.1.1 流标识
流通过一个31位的无符号整型进行标识。客户端初始化的流必须使用一个偶数作为流标识，服务端初始化的流必须使用一个奇数作为流标识。流标识为0x00的流用于标识连接控制信息，该标识不能用于建立其他新流。

新的流标识必须大于端点已经打开或者保留的流的标识，这是为了管理使用HEADERS帧打开的流或者使用PUSH_PROMISE保留的流。端点收到一个无法识别的流必须当做一个协议错误类型的连接错误（第5.4.1节）。

HEADERS帧将把由帧头中的流标识符标识的客户端发起的流从“空闲”转换为“打开”。PUSH_PROMISE帧将把帧体中的Promised stream ID字段标识的服务端发起的流从“空闲”转换为“保留（本地）”或“保留（远程）”。

当一个流从“空闲”状态转换为其他状态，所有对端打开的具有较小的流标识的处于空闲状态的流的状态会立即转换为“关闭”。也就是说一个端点可能会跳过一个流标识符，效果就是跳过的标识符的流被立即关闭。

流标识不能被重复使用。长连接会造成可用的流标识被用尽。客户端不能使用一个新的流标识建立一个新流，但是可以使用一个新的连接建立一个新流。服务端不能使用一个新的流标识，但是可以发送一个GOAWAY帧强制客户端为一个新流重新打开一个连接。

### 5.1.2 流的并发
对端可以使用SETTINGS帧中的SETTINGS_MAX_CONCURRENT_STREAMS参数限制并发活跃的流的数量。流的最大并发数设置由端点决定，并且对接收到这个设置的端点生效。也就是说，客户端指定服务端可以发起的最大并发流数，服务端指定客户端可以发起的最大并发流数。

处于打开状态、半关闭（本地/远端）的流计入最大并发流数。这三种状态的流计入SETTINGS_MAX_CONCURRENT_STREAMS设置中公告的限制。保留（本地/远端）状态不会计入流的控制。

端点一定不能超过对端设置的最大并发流数的限制。端点收到一个HEADERS帧之后，如果造成了最大并发流数的限制，必须将其视为协议错误胡拒绝流类型的流错误，选择哪一种错误类型取决于端点是否希望自动重试（详见第8.7节）。

端点如果希望将SETTINGS_MAX_CONCURRENT_STREAMS的值减小到低于当前打开流数，可以关闭超过新值的流，也可以允许流完成。

## 5.2 流控
使用流进行多路复用会引入对TCP连接使用的争用，导致流被阻塞。流控机制确保在同一个连接上的流不会对其他流造成毁灭性的影响。流控适用于双向流和整个连接。

HTTP/2通过WINDOW_UPDATE帧（第6.9节）实现流控。

### 5.2.1 流控原理
HTTP/2流的流控旨在不改变协议的前提下使用许多流量控制算法做流控。以下是HTTP/2流控的特征。

1.流控是作用于连接的。HTTP/2流控是作用在单跳的两个端点之间，而不是整个端对端的路径。
2.通过WINDOW_UPDATE帧进行流控。接收方通告在整个连接上和在一个流上接收的字节数。这是基于信用的机制。
3.接收方整体控制流量的定向控制。接收方可能会选择一个它希望的每个流和整个连接的窗口大小。发送方必须尊重接收方提议的流控限制。客户端、服务端和中间设备作为接收方独立的通告他们的流量控制窗口，发送方发送数据的时候遵守对端设置流控限制。
4.新建的流和整个连接的流控窗口的大小初始值是65535个字节
5.帧类型决定流控是否适用于该帧。在本文档中指定的帧中，只有DATA帧受流控制；其他帧类型不使用通告的流控窗口空间。这样能够保证重要的控制帧不被流控阻塞。
6.一个端点可以选择禁用它自己的流控，但是一个端点不能忽略对端的流控信令。
7.HTTP/2只定义了WINDOW_UPDATE帧的格式和语义（第6.9节）。该文档没有规定接收方如何决定什么时候发送该帧或者设置什么值，也没有指定发送者如何发送这些数据。实现该协议的实例可以自由选择任何适合他们需要的算法。

实例有责任设置发送的请求和响应的优先级、选择如何避免请求的队头阻塞以及管理新流的创建。流控算法的选择可以和任何流控算法通用。

### 5.2.2 适当使用流控
流控是为了保护资源受限的端点。例如，一个代理服务器需要和其他连接共享内存，而且可能有一个较慢的上游服务器和一个较快的下游服务器。流控可以解决当接收方无法在一个连接上收到请求，但是想继续在同一个连接上处理其他的流的场景。

不需要使用流控的部署可以通告最大流控窗口大小是2^31-1，并且在收到数据的时候通过发送WINDOW_UPDATE帧维持该窗口大小。这样有效禁用了接收方的流控。想法，发送方必须始终遵守接收方通告的流控窗口大小。

有资源限制（比如内存）的部署可以使用流控限制对端可以使用的内存大小。然而，请注意，如果在不知道带宽*延迟乘积的情况下启用流控制，这可能会导致可用网络资源不充分利用。

即使知道当前带宽*延迟的乘积，流控也很困难。只要有数据可读，端点必须从TCP接收缓冲区中读取和处理HTTP/2帧。如果关键帧，比如WINDOW_UPDATE帧，没有及时读取和处理，可能会造成死锁。及时读取帧不会使端点暴露于资源耗尽攻击，因为HTTP/2流控制限制了资源使用。

### 5.2.3 流控性能
如果一个端点不能保证在一个连接上，对端的可用流控窗口空间总是大于对端的带宽*延迟，则其接收吞吐量将受到HTTP/2流控制的限制。这将导致性能下降。

及时发送WINDOW_UPDATE帧可以提升性能。端点想要提高接收吞吐量的需要与管理资源耗尽风险的需要之间取得平衡，在定义管理窗口大小的策略时，应仔细注意第10.5节。

## 5.3 优先级
在HTTP/2等多路复用协议中，优先分配带宽和计算资源到流对于获得良好性能至关重要。糟糕的优先级方案可能会导致HTTP/2性能不佳。如果TCP层没有并行性，性能可能会比HTTP/1.1差得多。

一个好的优先级排序方案受益于上下文知识的应用，例如资源的内容、资源是如何相互关联的，以及对端将如何使用这些资源。特别是，客户端可以拥有与服务器优先级相关的请求优先级的知识。这样的话，让客户端提供优先级信息可以提高性能。

### 5.3.1 RFC7540中的优先级背景
RFC7540定义了一个用于发送请求优先级的丰富系统。然而，事实证明，这个系统很复杂，而且没有统一实施。

灵活的方案意味着客户端可以以非常不同的，几乎没有一致性的方式表达优先级。对于服务器来说，实现对该方案的通用支持是复杂的。客户端和服务器的优先级情况是不相同的。许多服务器部署在优先处理请求时忽略了客户端信令。

简而言之，RFC7540中定义的优先级信令是不成功的。

### 5.3.2 该文档中的优先级信令 
HTTP/2中不支持RFC7540中定义的优先级信令。本文档中不包括与优先级信令相关的大部分文本，保留了帧字段的描述和一些强制性处理，以确保本文档的实现与使用RFC 7540中描述的优先级信令的实现保持互操作性。

RFC7540优先级方案的详细描述仍在[RFC7540]的第5.3节中。

在许多情况下，为了获得良好的性能，信令优先级信息是必要的。在信令优先级信息很重要的情况下，鼓励端点使用替代方案，例如[HTTP-优先级](https://datatracker.ietf.org/doc/html/rfc9218)中描述的方案。

尽管RFC 7540的优先级信令没有被广泛采用，但在没有更好的信息的情况下，它提供的信息仍然是有用的。在HEADERS或PRIORITY帧中接收优先级信令的端点可以从该信息中受益。特别是，在没有替代方案的情况下，获取这些信息的实现比丢弃这些信息的实现更加受益。

在没有任何优先级信令的情况下，服务器应该使用其他上下文信息来确定请求的优先级。服务器可能会将完全没有信令解释为客户端尚未实现该功能。众所周知，[RFC7540]第5.3.5节中描述的默认值在大多数情况下性能较差，客户端户服务端不太可能特意使用它们。

## 5.4 错误处理
HTTP/2框架允许两类错误：

导致整个连接不可用的错误情况是连接错误
单个流中的错误是流错误

错误代码列表在第7节中介绍。

端点可能会遇到会导致多个错误的帧。实例在处理过程中可能会发现多个错误，但它们最多应该报告一个流错误和一个连接错误。

给定流上报告的第一个流错误会阻止报告该流上的任何其他错误。相比之下，该协议允许多个GOAWAY帧，尽管端点应该只报告一种类型的连接错误，但是如果在优雅关闭期间遇到错误，除了包含NO_ERROR的任何之前的GOAWAY帧之外，端点还可以发送带有新错误代码的额外GOAWAY帧。

如果一个端点检测到多个不同的错误，它可以选择报告其中任何一个错误。如果帧导致连接错误，则必须报告该错误。此外，当端点检测到错误情况时，它可以使用任何适用的错误代码；通用错误代码（如PROTOCOL_ERROR或INTERNAL_ERROR）总是可以用来代替更具体的错误代码。

### 5.4.1 连接错误处理
连接错误是指阻止帧层进一步处理或破坏任何连接状态的任何错误。

遇到连接错误的端点应该首先发送一个GOAWAY帧（第6.8节），其中包含它从对等端成功接收到的最后一个流的流标识符。GOAWAY帧包含一个错误代码（第7节），指示连接终止的原因。在发送错误条件的GOAWAY帧后，端点必须关闭TCP连接。

接收方点可能无法可靠地接收GOAWAY帧。如果发生连接错误，GOAWAY帧只是会尽最大努力与对方沟通连接终止的原因。

端点可以随时结束连接。特别是，端点可以选择将流错误视为连接错误。如果情况允许，端点应该在结束连接时发送GOAWAY帧。

### 5.4.2 流错误处理
流错误是与特定流相关的错误，不影响其他流的处理。

检测到流错误的端点会发送一个RST_STREAM帧（第6.4节），其中包含发生错误的流的流标识符。RST_STREAM帧包括指示错误类型的错误代码。

RST_STREAM是端点可以在流上发送的最后一个帧。发送RST_STREAM帧的端点必须准备好接收对端发送的或排队等待发送的任何帧。除非这些帧修改了连接状态（例如为字段部分的压缩（第4.3节）或流控的状态维护），否则可以忽略。

通常，端点不应为任何流发送多个RST_STREAM帧。然而，如果端点在超过一个往返时间后接收到已经关闭的流上的帧，则可能会发送额外的RST_STREAM帧。这种行为用来处理行为不端的一些实例的实现。

为了避免循环，端点一定不能发送RST_STREAM来响应RST_STREAM帧。

### 5.4.3 连接终止
如果TCP连接关闭或重置，而流仍处于“打开”或“半关闭”状态，则受影响的流无法自动重试（详见第8.7节）。

## 5.5 HTTP/2扩展
HTTP/2允许协议的扩展。在本节所述的限制范围内，协议扩展可用于提供额外服务或更改协议的任何方面。扩展仅在单个HTTP/2连接范围内有效。

这适用于本文档中定义的协议元素。这不会影响HTTP的现有扩展选项，例如定义新方法、状态吗或字段（请参阅[HTTP]的第16节）。

允许扩展使用新的帧类型（第4.1节）、新的设置（第6.5节）或新的错误代码（第7节）。管理这些扩展点的注册表在[RFC7540]的第11节中定义。

实例必须忽略所有可扩展协议元素中的未知或不受支持的值。实例必须丢弃具有未知或不受支持类型的帧。这意味着，任何扩展点都会被安全地使用，而无需事先安排或协商。但是，不允许出现在字段块中间的扩展帧（第4.3节），这种必须被视为协议错误类型的连接错误（第5.4.1节）。

扩展应避免更改本文档中定义的协议元素或未定义扩展机制的元素。这包括对帧布局的更改、对帧组成HTTP消息的方式的添加或更改（第8.1节）、伪标头字段的定义，或对端点可能视为连接错误的任何协议元素的更改（第5.4.1节）。

更改现有协议元素或状态的扩展必须在使用前进行协商。例如，在对方给出可接受的肯定信号之前，不能使用更改HEADERS帧布局的扩展。在这种情况下，需要进行必要的协商才能使得修改后的帧布局生效。例如，将DATA帧以外的帧视为流控制需要两个端点都理解该语义，因此这只能通过协商来实现。

该文档没有强制指定协商扩展使用的方法，但指出使用设置（第6.5.2节）实现此目的。如果端点双方都设置了一个表示愿意使用该扩展的值，则可以使用该扩展。如果将设置用于扩展协商，则必须以最初禁用扩展的方式定义初始值。

# 6 帧定义
本规范定义了多种帧类型，每种帧类型由一个唯一的8位类型代码标识。每种帧类型在建立和管理整个连接或单个流时都有不同的目的。

特定帧类型的传输可以改变连接的状态。如果端点无法保持连接状态的同步视图，则连接内的成功通信将不再可能。因此，端点必须对使用任何给定帧对状态的影响有共同的理解。

## 6.1 DATA帧
数据帧（类型=0x00）传输与流相关联的任意可变长度的字节序列。例如，一个或多个DATA帧用于承载HTTP请求或响应消息内容。

数据帧也可能包含填充字符。填充字符可以添加到DATA帧中，以掩盖消息的大小。填充字符是一种安全功能；见第10.7节。
```
DATA Frame {
  Length (24),
  Type (8) = 0x00,

  Unused Flags (4),
  PADDED Flag (1),
  Unused Flags (2),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Data (..),
  Padding (..2040),
}
```
图3：数据帧格式

长度、类型，未使用的标识和流标识字段在第4节中描述。数据帧有效载荷包含下面其他的字段：

填充长度：是一个8位字段表示帧中填充的字节长度。这个字段是有条件的，仅在设置了填充标识时才存在。

数据：应用层数据。数据量是请求或者响应去掉其他头部信息之后的剩余部分。

填充字符：填充字符不包含应用程序语义值。发送时，填充字符必须设置为零。接收方没有义务验证填充字符的语义，但可能将非零填充字符视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。

数据帧定义了下列标识：

填充标识：设置PADDED标识后表示存在填充长度字段及其描述的任何填充。

流结束符：设置END_STREAM标识表示这个帧是在这个流上端点发送的最后一个帧。设置此标识会导致流进入“半关闭”状态或“关闭”状态之一（第5.1节）。

注意：在发送所有数据后，端点可以通过发送一个长度为零的数据帧，并且该帧带有END_STREAM标识来关闭流。只有当端点不发送trailers时，才可能出现这种情况，因为通常出现在HEADERS帧上携带END_STREAM标识来关闭流，见第8.1节。

数据帧必须与流相关联。如果接收到流标识符字段为0x00的数据帧，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

数据帧受流控制，只能在流处于“打开”或“半关闭（远程）”状态时发送。整个数据帧的内容都包含在流控制中，包括Pad Length和Padding字段（如果存在）。如果收到一个数据帧，其流不处于“打开”或“半关闭（本地）”状态，则接收方必须以STREAM_CLOSED类型的流错误（第5.4.2节）进行响应。

填充字节的总数由“填充长度”字段的值决定。如果填充长度等于或大于帧有效载荷的长度，则接收方必须将其视为协议错误类型的连接错误（第5.4.1节）。

注意：通过包含一个值为零的填充长度字段，帧的大小可以增加一个字节。

## 6.2 HEADERS帧
HEADERS帧（类型=0x01）用于打开流（第5.1节），并额外携带字段块片段。尽管名为HEADERS，但HEADERS帧可以携带头部部分或尾部部分。HEADERS帧可以在“空闲”、“保留（本地）”、“打开”或“半关闭（远程）”状态下在流上发送。
```
HEADERS Frame {
  Length (24),
  Type (8) = 0x01,

  Unused Flags (2),
  PRIORITY Flag (1),
  Unused Flag (1),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flag (1),
  END_STREAM Flag (1),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  [Exclusive (1)],
  [Stream Dependency (31)],
  [Weight (8)],
  Field Block Fragment (..),
  Padding (..2040),
}
```
图4：HEADERS帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。HEADERS帧有效载荷包含下面其他的字段：

填充长度：是一个8位字段表示帧中填充的字节长度。这个字段是有条件的，仅在设置了填充标识时才存在。

独家：使用一位表示的标识。仅当设置了优先级标识时，此字段才存在。HEADERS帧中的优先级信号已被弃用；见第5.3.2节。

流依赖性：31位流标识符。仅当设置了优先级标识时，此字段才存在。

权重：一个无符号的8位整数。仅当设置了优先级标识时，此字段才存在。

字段块段：见第4.3节

填充字符：填充字符不包含应用程序语义值。发送时，填充字符必须设置为零。接收方没有义务验证填充字符的语义，但可能将非零填充字符视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。

HEADERS帧定义了一下标识：

优先级：设置后该标识后，表示存在独家、流依赖性和权重字段。

填充标识：设置PADDED标识后表示存在填充长度字段及其描述的任何填充。

HEADER帧结束标识（0x04）：设置END_HEADERS标识后表示此帧包含整个字段块（第4.3节），后面没有任何CONTINUATION帧。

  对于同一流，没有设置END_HEADERS标识的HEADERS帧后面必须有一个CONTINUATION帧。接收器必须将收到的任何其他类型的帧或不同流上的帧视为协议错误类型的连接错误（第5.4.1节）。

流结束标识（0x01）：设置流结束标识时表示字段块（第4.3节）是端点为识别的流发送的最后一个字段块。

  带有END_STREAM标识集的HEADERS帧表示流的结束。但是，设置了END_STREAM标识的HEADERS帧后面可以是同一流上的CONTINUATION帧。从逻辑上讲，CONTINUATION帧是HEADERS帧的一部分。

HEADERS帧的有效载荷包含一个字段块片段（第4.3节）。一个字段块的内容在一个HEADERS帧中未发送结束会在CONTINUATION帧中继续发送（第6.10节）。

HEADERS帧必须与流相关联。如果接收到流标识符字段为0x00的HEADERS帧，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

第4.3节已经描述HEADERS帧对连接状态改变的影响。

填充字节的总数由“填充长度”字段的值决定。如果填充长度等于或大于帧有效载荷的长度，则接收方必须将其视为协议错误类型的连接错误（第5.4.1节）。

注意：通过包含一个值为零的填充长度字段，帧的大小可以增加一个字节。

## 6.3 PRIORITY帧
PRIORITY帧（类型=0x02）已弃用，见第5.3.2节。优先级帧可以在任何流状态下发送，包括空闲或关闭的流。
```
PRIORITY Frame {
  Length (24) = 0x05,
  Type (8) = 0x02,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Exclusive (1),
  Stream Dependency (31),
  Weight (8),
}
```
图5：优先级帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。PRIORIY帧的有效载荷包含下面其他的字段：

独有：一个1位的标识

流独立性：一个31位的流标识符
当前流与父流的其他依赖流共享父资源的优先级权重。例如，若流B和流C都依赖流A，则A的带宽会按权重分配给B和C
独占依赖（E=1）：
当前流会取代父流的所有现有依赖关系，原有依赖流（如流B、流C）变为当前流的子流。例如：
* 原结构：流A → 流B、流C
* 独占后：流A → 流D（E=1） → 流B、流C
此时，流D独占流A的资源，而流B和流C的优先级由流D的权重决定

这里的带宽是逻辑带宽，每个流和每个连接上都有自己的流量控制窗口
带宽分配的核心机制
* 优先级与权重
HTTP/2允许客户端通过PRIORITY帧为流设置依赖关系和权重（1~256）。服务器根据权重比例分配带宽：
    * 例如，流A权重200，流B权重100，则流A获得的带宽是流B的两倍。
    * 依赖关系树中，父流优先分配资源，子流按权重共享剩余带宽。
* 独占依赖（E标志位）
若流设置为独占依赖（E=1），它将独占父流的全部带宽，其他依赖流降级为其子流。

权重：一个无符号8位的整数

优先级帧不定义任何标识。

优先级帧始终标识流。如果接收到流标识符为0x00的优先级帧，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

发送或接收优先级帧不会影响任何流的状态（第5.1节）。优先级帧可以在任何状态下的流上发送，包括“空闲”或“关闭”状态。优先级帧不能在属于单个字段块的连续帧之间发送（第4.3节）。

长度不是5个字节的优先级帧必须被视为FRAME_SIZE_ERROR类型的流错误（第5.4.2节）。
帧体固定5个字节。

## 6.4 RST_STREAM帧
RST_STREAM帧（类型=0x03）允许立即终止流。发送RST_STREAM以请求取消流或指示发生了错误情况。
```
RST_STREAM Frame {
  Length (24) = 0x04,
  Type (8) = 0x03,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Error Code (32),
}
```
图6：RST_STREAM帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。此外，RST_STREAM帧包含一个无符号的32位整数，用于标识错误代码（第7节）。错误代码指示流终止的原因。

RST_STREAM帧没有定义任何标识。

RST_STREAM帧完全终止引用的流，并使其进入“关闭”状态。在接收到流上的RST_STREAM后，除了PRIORITY帧，接收器不得在该流上发送额外的帧。然而，在发送RST_STREAM帧之后，发送方必须准备好接收和处理在流上发送的额外帧，这些帧可能是在RST_STREAM帧到达之前由对方发送的。

RST_STREAM帧必须与流相关联。如果收到流标识符为0x00的RST_STREAM帧，接收方必须将其视为协议错误类型的连接错误（第5.4.1节）。

对于处于“空闲”状态的流，不得发送RST_STREAM帧。如果接收到标识空闲流的RST_STREAM帧，接收方必须将其视为协议错误类型的连接错误（第5.4.1节）。

长度不是4个字节的RST_STREAM帧必须被视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。

## 6.5 SETTINGS帧
SETTINGS帧（类型=0x04）传输了影响端点通信方式的配置参数，例如对端的行为偏好和约束。SETTINGS帧也用于确认收到这些设置。单独而言，SETTINGS帧中的配置参数称为“设置”。

设置没有经过协商协商，它们描述了发送方的特征，这些特征由接收方使用。端点双方可以通告同一设置的不同值。例如，客户端可能会设置一个较高的初始流控窗口，而服务器可能会设置较低的值来节省资源。

SETTINGS帧必须在连接开始时由两个端点发送，并且可以在连接生命周期内的任何其他时间由任一端点发送。实例必须支持本规范定义的所有设置。

SETTINGS帧中的每个参数都会替换该参数的任何现有值。设置按照其出现的顺序进行处理，SETTINGS帧的接收方不需要保持除每个设置的当前值之外的任何状态。因此，SETTINGS参数的值是接收方看到的最后一个值。

SETTINGS帧的接收方需要确认收到SETTINGS帧。为了实现这一点，SETTINGS帧定义了ACK标识：

ACK（0x01）：当设置ACK时标识表示该帧确认收到并应用了对端发送的SETTINGS帧。当设置此位时，SETTINGS帧的有效载荷必须为空。接收方收到设置了ACK标识且长度字段值不是0的SETTINGS帧时，必须将其视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。有关更多信息，请参阅第6.5.3节（“设置同步”）。

设置帧始终适用于一个连接，而不是单个流。SETTINGS帧的流标识符必须为零（0x00）。如果端点收到流标识符字段不是0x00的SETTINGS帧，则端点必须以协议错误类型的连接错误（第5.4.1节）进行响应。

SETTINGS帧会影响连接状态。格式错误或不完整的SETTINGS帧必须被视为协议错误类型的连接错误（第5.4.1节）。

长度不是6个字节的倍数的SETTINGS帧必须被视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。

### 6.5.1 帧格式
SETTINGS帧的帧有效载荷由零个或多个设置组成，每个设置由一个无符号的16位设置标识符和一个无符号的32位值组成。
```
SETTINGS Frame {
  Length (24),
  Type (8) = 0x04,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Setting (48) ...,
}

Setting {
  Identifier (16),
  Value (32),
}
```
图7：SETTINGS帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。SETTINGS帧的帧有效载荷包含任意数量的设置字段，每个字段由以下部分组成：

标识符：16位设置标识符；见第6.5.2节。
值：32位的无符号设置值

### 6.5.2 设置项定义
定义了以下设置：
SETTINGS_HEADER_TABLE_SIZE（0x01）：此设置允许发送方以字节为单位通知远端用于解码字段块的压缩表的最大大小。编码器可以通过特定于字段块内压缩格式的信号来选择等于或小于此值的任何值（请参阅[compression]）。初始值为4096个字节。

SETTINGS_ENABLE_PUSH（0x02）：此设置可用于启用或禁用服务器推送。如果服务器收到此参数设置为0，则不得发送PUSH_PROMISE帧，见第8.4节。将此参数设置为0并得到确认的客户端必须将PUSH_PROMISE帧的接收视为协议错误类型的连接错误（第5.4.1节）。

SETTINGS_ENABLE_PUSH的初始值为1。对于客户端，此值表示它愿意接收PUSH_PROMISE帧。对于服务器，此初始值无效，相当于值0。除0或1之外的任何值都必须被视为协议错误类型的连接错误（第5.4.1节）。

服务器不得将此值显式设置为1。服务器在发送SETTINGS帧时可以选择省略此设置，但如果服务器确实包含值，则必须为0。客户端必须将SETTINGS_ENABLE_PUSH设置为1的SETTINGS帧的接收视为协议错误类型的连接错误（第5.4.1节）。

SETTINGS_MAX_CONCURRENT_STREAMS（0x03）：此设置指示发送方允许的最大并发流数。这个限制是有方向性的，它适用于发送方允许接收方创建的流的数量。这个设置的初始值是没有限制的。建议该值不小于100，以免不必要地限制并发性。

端点不应将SETTINGS_MAX_CONCURRENT_STREAMS的值为0视为特殊值。零值确实会阻止新流的创建，然而，对于活动流的任何限制被耗尽，也可能发生这种情况。服务器应仅在短时间内设置零值。如果服务器不希望接受请求，则关闭连接更为合适。

SETTINGS_INITIAL_WINDOW_SIZE（0x04）：此设置表示流级别的流控的发送方初始窗口大小（以字节为单位）。初始值为2^16-1（65535）个字节。

此设置会影响所有流的窗口大小（见第6.9.2节）。

大于最大流量控制窗口大小2^31-1的值必须被视为FLOW_CONTROL_ERROR类型的连接错误（第5.4.1节）。

SETTINGS_MAX_FRAME_SIZE（0x05）：此设置以字节为单位表示发送方愿意接收的最大帧有效载荷的大小。

  初始值为2^14（16384）个字节。端点通告的值必须在此初始值和允许的最大帧大小（2^24-1或16777215个字节）之间，包括这两个值。超出此范围的值必须被视为协议错误类型的连接错误（第5.4.1节）。

SETTINGS_MAX_HEADER_LIST_SIZE（0x06）：此设置表示发送方发送给对端的以字节为单位的其准备接受的最大字段部分的大小。该值基于字段行的未压缩的大小，包括以字节为单位的名称和值的长度，以及每条字段行3的2个字节长度。

对于任何给定的请求，可能会通告一个更小的限制。此设置的初始值不受限制。

端点如果接收到具有任何未知或不受支持标识符的SETTINGS帧必须忽略该设置。

### 6.5.3 设置同步
SETTINGS中的大多数值都受益于或需要了解对方何时收到并应用了更改的参数值。为了提供这样的同步时间点，未设置ACK标识的SETTINGS帧的接收者必须在收到后尽快应用更新的设置。设置帧按照接收顺序进行确认。

SETTINGS帧中的值必须按照它们出现的顺序进行处理，值之间没有其他帧处理。必须忽略不支持的设置。处理完所有值后，接收方必须立即发出设置了ACK标识的SETTINGS帧。在接收到设置了ACK标识的SETTINGS帧后，更改设置的发送方可以依赖于已应用的最旧未确认SETTING帧的值。

如果SETTINGS帧的发送方在合理的时间内没有收到确认，则可能会发出设置超时的连接错误（第5.4.1节）。在设置超时时，需要为对端的处理延迟留出一些余地，仅基于端点之间的往返时间的超时可能会导致虚假错误。

## 6.6 PUSH_PROMISE帧
PUSH_PROMISE帧（类型=0x05）用于提前通知对端发送方打算发起的流。PUSH_PROMISE帧包括端点计划创建的流的无符号31位标识符，以及为流提供额外上下文的字段部分。第8.4节详细描述了PUSH_PROMISE帧的使用。
```
PUSH_PROMISE Frame {
  Length (24),
  Type (8) = 0x05,

  Unused Flags (4),
  PADDED Flag (1),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  [Pad Length (8)],
  Reserved (1),
  Promised Stream ID (31),
  Field Block Fragment (..),
  Padding (..2040),
}
```
图8：PUSH_PROMISE帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。PUSH_PROMISE帧有效载荷具有以下附加字段：

填充长度：是一个8位字段表示帧中填充的字节长度。这个字段是有条件的，仅在设置了填充标识时才存在。

承诺流标识符：一个无符号的31位整数，用于标识为发送PUSH_PROMISE帧的一端保留的流。承诺的流标识符必须是发送方发送的下一个流的有效选择（见第5.1.1节中的“新流标识符”）。

字段块段：包含请求控制数据和报头部分信息（第4.3节）。

填充字符：填充字符不包含应用程序语义值。发送时，填充字符必须设置为零。接收方没有义务验证填充字符的语义，但可能将非零填充字符视为PROTOCOL_ERROR类型的连接错误（第5.4.1节）。

PUSH_PROMISE帧定义了一下标识：

填充标识：设置PADDED标识后表示存在填充长度字段及其描述的任何填充。

HEADER帧结束标识（0x04）：设置END_HEADERS标识后表示此帧包含整个字段块（第4.3节），后面没有任何CONTINUATION帧。

  对于同一个流，没有设置END_HEADERS标识的PUSH_PROMISE帧后面必须有一个CONTINUATION帧。接收方必须将收到的任何其他类型的帧或不同流上的帧视为协议错误类型的连接错误（第5.4.1节）。

PUSH_PROMISE帧必须仅在处于“打开”或“半关闭（远程）”状态的对端创建的流上发送。PUSH_PROMISE帧的流标识符指示它所关联的流。如果流标识符字段指定值0x00，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

承诺的流不需要按照承诺的顺序使用。PUSH_PROMISE帧仅保留流标识符以供以后使用。

如果对端的SETTINGS_ENABLE_PUSH设置为0，则不得发送PUSH_PROMISE。已设置此设置并收到确认的端点必须将PUSH_PROMISE帧的接收视为协议错误类型的连接错误（第5.4.1节）。

PUSH_PROMISE帧的接收方可以通过向PUSH_PROMISE帧的发送方返回引用承诺流标识符的RST_STREAM帧来选择拒绝承诺流。

PUSH_PROMISE帧以两种方式修改连接状态。首先，包含字段块（第4.3节）可能会修改字段部分压缩所保持的状态。其次，PUSH_PROMISE帧还保留了一个流以供以后使用，被承诺的流进入“保留（本地）”或“保留（远程）”状态。发送方不得在流上发送PUSH_PROMISE帧，除非该流是“打开”或“半关闭（远程）”的；发送方必须确保承诺的流是新流的流标识符的有效选择（第5.1.1节）（即承诺流必须处于“空闲”状态）。

由于PUSH_PROMISE帧保留了一个流，忽略PUSH_PROMISE帧会导致流状态变得不确定。接收方必须将既不是“打开”也不是“半关闭（本地）”状态的流上的PUSH_PROMISE帧的接收视为协议错误类型的连接错误（第5.4.1节）。但是，在相关流上发送RST_STREAM帧的端点必须处理可能在接收和处理RST_STREAM帧之前创建的PUSH_PROMISE帧。

接收方必须将承诺非法流标识符的PUSH_PROMISE帧（第5.1.1节）的接收视为协议错误类型的连接错误（第5.4.1节）。请注意，非法流标识符是指当前未处于“空闲”状态的流的标识符。

填充字节的从长度由“填充长度”字段的值决定。如果填充长度等于或大于帧有效载荷的长度，则接收方必须将其视为协议错误类型的连接错误（第5.4.1节）。

注意：包含一个值为零的填充长度字段，帧的大小可以增加一个八位字节。

## 6.7 PING帧
PING帧（类型=0x06）是一种用于测量发送方和接收方之间的最小往返时间以及确定空闲连接是否仍然有效的机制。PING帧可以从任何端点发送。
```
PING Frame {
  Length (24) = 0x08,
  Type (8) = 0x06,

  Unused Flags (7),
  ACK Flag (1),

  Reserved (1),
  Stream Identifier (31) = 0,

  Opaque Data (64),
}
```
图9：PING帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。

除了帧头之外，PING帧必须在帧有效载荷中包含8个字节的不透明数据。发送方可以包含它选择的任何值，并以任何方式使用这些八位字节。

不包含ACK标识的PING帧的接收方必须发送一个设置了ACK标识的PING帧作为响应，并具有相同的帧有效载荷。响应的PING帧应被赋予比任何其他帧更高的优先级。

PING帧定义了以下标识：

响应标识（0x01）：设置后，ACK标识表示此PING帧是PING帧的响应。端点必须在PING帧响应中设置此标识。端点不得响应包含此标识的PING帧。

PING帧不与任何单个流相关联。如果接收到的PING帧的流标识符字段值不是0x00，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

接收长度字段值不是8的PING帧必须被视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。

## 6.8 GOAWAY帧
GOAWAY帧（类型=0x07）用于启动连接关闭或发出严重错误情况的信号。GOAWAY帧允许端点优雅地停止接受新流，同时仍然完成对先前建立的流的处理。这允许执行管理操作，如服务器维护。

在开始新流的端点和发送GOAWAY帧的远端之间存在固有的竞争条件。为了处理这种情况，GOAWAY帧包含发送方上已经处理或可能处理的最后一个对端发起的流的流标识符。例如，如果服务器发送GOAWAY帧，则标识的流是客户端发起的标识符最高的流。

一旦GOAWAY帧被发送，如果流的标识符高于所包含的最后一个流标识符，则发送方将忽略在接收方发起的流上发送的帧。GOAWAY帧的接收方不得在连接上打开其他的流，虽然可以为新流建立新的连接。

如果GOAWAY帧的接收方在流标识符高于GOAWAY帧中指示的流标识符的流上发送了数据，则这些流不会或将不会被处理。GOAWAY帧的接收方可以将这些流视为从未创建过，从而允许稍后在新连接上重试这些流。

端点在关闭连接之前应始终发送GOAWAY帧，以便对端可以知道流是否已被部分处理。例如，如果HTTP客户端在服务器关闭连接的同时发送POST，如果服务器没有发送GOAWAY帧来指示对哪些流采取了行动，则客户端无法知道服务器是否开始处理该POST请求。

端点可能会选择关闭连接，而不对行为不端的对等端发送GOAWAY帧。

在关闭连接之前可能不会发送一个GOAWAY帧。如果接收方收到一个GOAWAY帧，并且不再使用这个连接，应该在关闭连接之前发送一个GOAWAY帧。
```
GOAWAY Frame {
  Length (24),
  Type (8) = 0x07,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31) = 0,

  Reserved (1),
  Last-Stream-ID (31),
  Error Code (32),
  Additional Debug Data (..),
}
```
图10：GOAWAY帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。

GOAWAY帧未定义任何标识。

GOAWAY帧作用于连接，而不是特定的流。端点必须将流标识符不是0x00的GOAWAY帧视为协议错误类型的连接错误（第5.4.1节）。

GOAWAY帧中的最后一个流标识符包含数值最大的流标识符，GOAWAY帧的发送方可能已经对其进行了一些处理，或者可能尚未对其进行任何处理。所有流，包括已识别的流，都可能已经以某种方式进行了处理。如果没有处理流，则最后一个流标识符可以设置为0。

注意：在这种情况下，“已处理”意味着流中的一些数据被传递给可能因此采取某些行动的更高层软件。

如果连接在没有GOAWAY帧的情况下终止，则最后一个流标识符极有可能是最大的流标识符。

在连接关闭前，未完全关闭的具有较低或相等流标识符的流上，除了HTTP GET、PUT或DELETE等幂等操作外，不可能重新尝试请求、事务或任何协议活动。任何使用更高流标识符的协议活动都可以使用新连接安全地重试。

流标识符小于或等于最后一个流标识符的流上的活动仍可能成功完成。GOAWAY帧的发送方可能会通过发送GOAWAY帧来优雅地关闭连接，即在所有正在进行的流完成之前，连接将保持在“打开”状态。

如果情况发生变化，端点可能会发送多个GOAWAY帧。例如，在优雅关闭期间发送带有NO_ERROR的GOAWAY帧的端点随后可能会遇到需要立即终止连接的情况。接收到的最后一个GOAWAY帧中的最后一条流标识符指示了哪些流可能已被处理。端点不得增加它们在最后一个流标识符中发送的值，因为对端可能已经在另一个连接上重试了未处理的请求。

当服务器关闭连接时，无法重试请求的客户端会丢失所有正在进行的请求。对于可能不使用HTTP/2为客户端提供服务的中间设备/中间服务器来说尤其如此。试图优雅地关闭连接的服务器应该发送一个初始GOAWAY帧，其中最后一个流标识符设置为2^31-1，并发送一个NO_ERROR代码，这向客户端发出关闭即将到来的信号，并禁止发起进一步的请求。为任何正在创建的流留出时间（至少一个往返时间）后，服务器可以发送另一个GOAWAY帧，其中包含更新的最后一个流标识符。这确保了连接可以优雅地关闭，而不会丢失请求。

在发送GOAWAY帧后，发送方可以丢弃由接收方发起的标识符高于识别的最后一个流的帧。但是，任何改变连接状态的帧都不能完全忽略。例如，必须对HEADERS、PUSH_PROMISE和CONTINUATION帧进行最低限度的处理，以确保字段部分的压缩所保持的状态是一致的（见第4.3节）；同样，数据帧必须被计入连接中的流控制窗口。未能处理这些帧可能会导致流控或字段部分压缩状态变得不同步。

GOAWAY帧还包含一个32位错误代码（第7节），其中包含关闭连接的原因。

端点可以将不透明数据添加到任何GOAWAY帧的帧有效载荷中。其他调试数据仅用于诊断目的，不具有语义含义。调试信息可能包含安全或隐私敏感数据。日志或以其他方式持久存储的调试数据必须有足够的保护措施，以防止未经授权的访问。

## 6.9 WINDOW_UPDATE帧
WINDOW_UPDATE帧（类型=0x08）用于实现流控制；概述见第5.2节。

流量控制在两个级别上运行：在每个单独的流和整个连接上。

这两种类型的流控都是逐跳的，即仅在两个端点之间。中间设备或服务器不会在依赖的连接之间转发WINDOW_UPDATE帧。然而，任何接收方对数据传输的节流都会间接导致流控信息向原始发送方的传递。

流控仅用于被标识为受流控的帧。在本文档中定义的帧类型中，这仅包括DATA帧。必须接收和处理不受流控的帧，除非接收方无法分配资源来处理该帧。如果接收方无法接收帧，则可能会返回FLOW_CONTROL_ERROR类型的流错误（第5.4.2节）或连接错误（第5.4节）。
```
WINDOW_UPDATE Frame {
  Length (24) = 0x04,
  Type (8) = 0x08,

  Unused Flags (8),

  Reserved (1),
  Stream Identifier (31),

  Reserved (1),
  Window Size Increment (31),
}
```
图11：WINDOW_UPDATE帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。WINDOW_UPDATE帧的帧有效载荷是一个保留位加上一个无符号的31位整数，表示除了现有的流控窗口之外，发送方还可以传输的字节数。流控窗口增量大小的合法范围是1到2^31-1（2147483647）个字节。

WINDOW_UPDATE帧未定义任何标识。

WINDOW_UPDATE帧可以作用于某个流或整个连接。流级别的流控中，帧的流标识符指示受影响的流；连接级别的流控中，值“0”表示整个连接是流控的主体。

接收方必须将流控窗口增量为0的WINDOW_UPDATE帧的接收视为协议错误类型的流错误（第5.4.2节）；连接流控窗上的错误必须被视为连接错误（第5.4.1节）。

WINDOW_UPDATE帧可以由发送了设置了END_STREAM标识的帧的对方发送。这意味着接收方可以在“半关闭（远程）”或“关闭”状态下接收流上的WINDOW_UPDATE帧。接收方不得将此视为错误（见第5.1节）。

接收流控制帧的接收方必须始终计算连接上的流对流控制窗口的贡献，除非接收方将其视为连接错误（第5.4.1节）。即使帧有错误，计算也是必要的。发送方按照流控窗口对帧进行计数，但如果接收方没有计数，发送方和接收方的流控窗口可能会变得不同。

长度不是4个字节长度的WINDOW_UPDATE帧必须被视为FRAME_SIZE_ERROR类型的连接错误（第5.4.1节）。

## 6.9.1 流控窗口
HTTP/2中的流控是使用每个发送方在每个流上保存的窗口来实现的。流控窗口是一个简单的整数值，指示允许发送方传输多少个字节的数据，因此，其大小是接收方缓冲能力的度量。

有两种流量控制窗口：流级别的流控窗口和连接级别的流控窗口。发送方不得发送长度超过接收方通告的任何一个流控窗口中可用空间的大小。如果任一流控窗口中没有可用空间，则可以发送长度为零且设置了END_STREAM标识的帧（即空数据帧）。

对于流量的计算，不包括9个字节的帧头。

在发送流控制帧后，发送方将流级别和连接级别的两种窗口中的可用空间都会减少传输帧的长度大小。

帧的接收方在消耗数据并释放流控窗口中的空间时发送WINDOW_UPDATE帧。为流级和连接级流控窗口发送单独的WINDOW_UPDATE帧。建议接收方具有适当的机制，以避免以非常小的增量发送WINDOW_UPDATE帧；参见[RFC1122]第4.2.3.3节。

收到WINDOW_UPDATE帧的发送方会按帧中指定的设置更新相应的窗口。

发送方不得允许流控窗口超过2^31-1个字节。如果发送方收到WINDOW_UPDATE帧，导致流控窗口超过此最大值，则必须根据需要终止流或连接。终止流通过发送方发送一个RST_STREAM帧，错误代码为FLOW_CONTROL_ERROR；对于连接，发送错误代码为FLOW_CONTROL_ERROR的GOAWAY帧。

来自发送方的和来自接收方的WINDOW_UPDATE帧彼此完全异步。此属性允许接收方积极更新发送方保留的窗口大小，以防止流停滞。

### 6.9.2 初始化流控窗口大小
当首次建立HTTP/2连接时，会创建初始流控窗口大小为65535个字节的新流。连接级别的流控窗口也是65535个字节。两个端点都可以通过在SETTINGS帧中包含SETTINGS_INITIAL_WINDOW_SIZE的值来调整新流的初始窗口大小。但只能使用WINDOW_UPDATE帧更改连接级别的流控窗口。

在收到为SETTINGS_INITIAL_WINDOW_SIZE设置值的SETTINGS帧之前，端点在发送被流控的帧时只能使用默认的初始窗口大小。同样，在收到WINDOW_UPDATE帧之前，连接级别的流控窗口是基于默认的初始窗口大小设置的。

除了更改尚未活动的流的流控窗口外，设置帧还可以更改具有活动流控窗口的流（即处于“打开”或“半关闭（远程）”状态的流）的初始流控窗口大小。当SETTINGS_INITIAL_WINDOW_SIZE的值发生变化时，接收方必须通过新值和旧值之间的差值来调整其维护的所有流控窗口的大小。

更改SETTINGS_INITIAL_WINDOW_SIZE可能会导致流控窗口中的可用空间变为负值。发送方必须跟踪负流控窗口，并且在收到导致流控窗口变为正的WINDOW_UPDATE帧之前，不得发送新的流控制帧。

例如，如果客户端在连接建立后立即发送60 KB的数据，而服务器将初始窗口大小设置为16 KB，则客户端在收到SETTINGS帧后将重新计算可用的流控窗口为-44 KB。客户端保留一个负流控窗口，直到WINDOW_UPDATE帧将窗口恢复为正值之后客户端才可以继续发送请求。

设置参数帧不能修改连接级别的流控窗口。

端点必须将导致任何流控窗口超过最大大小的SETTING_INITIAL_WINDOW_SIZE值的修改视为FLOW_CONTROL_ERROR类型的连接错误（第5.4.1节）。

### 6.9.3 减少流控窗口大小
希望使用比当前大小更小的流控窗口的接收方可以发送新的设置帧。但是，接收方必须准备好接收超过此窗口大小的数据，因为发送方可能会在处理SETTINGS帧之前发送超过限制窗口大小的数据。

在发送减小初始流控窗口大小的SETTINGS帧后，接收方可以继续处理超过流控制限制的流。接收方可以不立即减少它为流控窗口保留的空间。如果接收方减少为流控窗口保留的空间，流的进度可能会停滞，除非接收方发送WINDOW_UPDATE帧来允许发送方恢复发送。接收方可能会为受影响的流（被流控的流）发送一个RST_STREAM帧，错误代码为FLOW_CONTROL_ERROR。

## 6.10 CONTINUATION帧
CONTINUATION帧（类型=0x09）用于继续一系列字段块片段（第4.3节）。可以发送任意数量的CONTINUATION帧，只要前一帧在同一流上，并且是没有设置END_HEADERS标识的HEADERS、PUSH_PROMISE或CONTINUTION帧。
```
CONTINUATION Frame {
  Length (24),
  Type (8) = 0x09,

  Unused Flags (5),
  END_HEADERS Flag (1),
  Unused Flags (2),

  Reserved (1),
  Stream Identifier (31),

  Field Block Fragment (..),
}
```
图12：CONTINUATION帧格式

长度、类型、未使用标识、保留和流标识符字段在第4节中进行了描述。CONTINUATION帧有效载荷包含一个字段块片段（第4.3节）。

CONTINUATION帧定义了以下标识：

END_HEADERS（0x04）：设置END_HEADERS标识表示此帧结束一个字段块（第4.3节）。

  如果未设置END_HEADERS标识，则此帧后面必须有另一个CONTINUATION帧。接收方必须将任何其他类型的帧或不同流上的帧的接收视为协议错误类型的连接错误（第5.4.1节）。

CONTINUATION帧对连接状态的改变在第4.3节中定义。

CONTINUATION帧必须与流相关联。如果接收到流标识符字段为0x00的CONTINUATIN帧，则接收方必须以协议错误类型的连接错误（第5.4.1节）进行响应。

CONTINUATION帧前面必须有一个HEADERS、PUSH_PROMISE或CONTINUATION帧，且不设置END_HEADERS标识。接收方发现违反此规则必须返回协议错误类型的连接错误（第5.4.1节）。

# 7 错误码
错误代码是在RST_STREAM帧和GOAWAY帧中使用的32位字段，用于传达流或连接错误的原因。

错误代码共享一个公共代码空间。一些错误代码仅适用于流或整个连接这两个上下文，未定义其他上下文的错误代码。

定义了以下错误代码：

NO_ERROR（0x00）：没有错误。例如，GOAWAY帧可能包含此代码表示连接正常关闭。

PROTOCOL_ERROR（0x01）：端点检测到未定义的协议错误。当没有更具体的错误代码时，可以使用此错误。

INTERNAL_ERROR（0x02）：端点遇到未知的内部错误。

FLOW_CONTROL_ERROR（0x03）：端点检测到对端违反流控协议。

SETTINGS_TIMEOUT（0x04）：端点发送了SETTINGS帧，但是没有及时收到响应。见第6.5.3节（配置项同步）。

STREAM_CLOSED（0x05）：端点在流状态是半关闭的状态下收到了帧。

FRAME_SIZE_ERROR（0x06）：端点收到一个大小无效的帧

REFUSED_STREAM（0x07）：端点在执行任何应用程序处理之前拒绝了流（详见第8.7节）。

CANCEL（0x08）：端点使用这个错误码表示不再需要流。

COMPRESSION_ERROR（0x09）：端点无法维护连接的字段部分的压缩上下文。

CONNECT_ERROR（0x0a）：CONNECT请求（第8.5节）建立的连接被重置或异常关闭。

ENHANCE_YOUR_CALM（0x0b）：端点检测到其对端可能产生过大负载的行为。

INADEQUATE_SECURITY（0x0C）：底层传输具有不符合最低安全要求的属性（见第9.2节）。

HTTP_1_1_REQUIRED（0x0d）：端点要求使用HTTP/1.1而不是HTTP/2

未知或不受支持的错误代码不得触发任何特殊行为。这些可以被实例视为INTERNAL_ERROR相同的行为。

# 8 HTTP/2中表达HTTP语义
HTTP/2是HTTP消息抽象的实例化（[HTTP]的第6节）。

## 8.1 HTTP消息帧
客户端使用以前未使用的流标识符在新流上发送HTTP请求（第5.1.1节）。服务器在与请求相同的流上发送HTTP响应。

HTTP消息（请求或响应）由以下部分组成：

1.一个包含报头部分的HEADERS帧（后面是零个或多个CONTINUATION帧）（参见[HTTP]的第6.3节），
2.包含消息内容的零个或多个DATA帧（见[HTTP]第6.4节），以及
3.可选地，一个包含尾部字段的HEADERS帧（后面跟着零个或多个CONTAINATION帧）（如果存在）（见[HTTP]的第6.5节）。

仅对于响应，服务器可以在包含最终响应的HEADERS帧之前发送任意数量的临时响应。临时响应由一个HEADERS帧（后面可能有零个或多个CONTINUATION帧）组成，其中包含临时（1xx）HTTP响应的控制数据和响应头部分（见[HTTP]第15节）。带有END_STREAM标识的HEADERS帧携带响应码（第8.1.1节）。

序列中的最后一个帧带有END_STREAM标识，注意设置END_STREAM标识的HEADERS帧后面可以是携带字段块任何剩余片段的CONTINUATION帧。

其他帧（来自任何流）不得出现在HEADERS帧和可能随后出现的任何CONTINUATIN帧之间。

HTTP/2使用DATA帧来承载消息内容。[HTTP/1.1]第7.1节中定义的分块传输编码不能在HTTP/2中使用；见第8.2.2节。

字段块中包含尾部字段，该字段块也终止流。也就是说，尾部字段包括一个以HEADERS帧开始的序列，后面是零个或多个CONTINUATION帧，其中HEADERS帧带有END_STREAM标识。尾部字段中不能包含伪头部（第8.3节）。在尾部字段中接收到伪头部的端点必须将请求或响应视为格式错误（第8.1.1节）。

在接收到创建请求的HEADERS帧或接收到最终（非信息性）状态码后，接收到没有设置END_STREAM标识的HEADEERS帧的端点必须将相应的请求或响应视为格式错误（第8.1.1节）。

HTTP请求/响应交换完全消耗单个流。请求以HEADERS帧开始，该帧将流置于“打开”状态。请求以一个设置了END_STREAM标识的帧结束，这导致客户端的流变为“半关闭（本地）”，服务器变为“半关闭（远程）”。响应流以HEADERS帧中的零个或多个临时响应开始，然后是包含最终响应码的HEADERS帧。

在服务器发送或客户端接收到设置了END_STREAM标识的帧（包括完成字段块的发送所需的任何CONTINUATION帧）后，HTTP响应完成。如果响应不依赖于尚未发送和接收的请求的任何部分，则服务器可以在客户端发送整个请求之前发送完整的响应。当此情况为真时，服务器可以在发送完整响应（即设置了END_STREAM标识的帧）后，通过发送错误代码为NO_ERROR的RST_STREAM帧，请求客户端无错误地中止请求的传输。客户端不能因为收到这样的RST_STREAM而丢弃响应，尽管客户端总是可以出于其他原因自行决定丢弃响应。

### 8.1.1 格式错误的消息
格式错误的请求或响应是指原本有效的HTTP/2帧序列，但由于存在无关帧、禁止字段或伪头部字段、缺少强制性伪头部字段，包含大写字段名或无效字段名/或值（在某些情况下；见第8.2节）而无效的请求或响应。

包含消息内容的请求或响应可以包括内容长度头部字段。如果内容长度头部字段的值不等于DATA帧有效载荷长度的总和，则请求或响应也会格式错误，除非消息被定义为没有内容。例如，204或304响应不包含响应体，对HEAD请求的响应也不包含响应体。如[HTTP]第6.4.1节所述，定义为无响应体的响应可能具有非零响应体长度的头部字段，即使DATA帧中不包含响应体内容。

处理HTTP请求或响应的中间设备/代理服务器（即任何不充当隧道的中间设备/代理服务器）不得转发格式错误的请求或响应。检测到的格式错误的请求或响应必须被视为PROTOCOL_ERROR类型的流错误（第5.4.2节）。

对于格式错误的请求，服务器可能会在关闭或重置流之前发送HTTP响应。客户端不得接受格式错误的响应。

逐步处理消息的端点可能在将请求或响应识别为格式错误之前执行了一些处理。例如，在没有收到完整请求的情况下，可能会生成信息代码或404状态响应码。同样，中间设备/服务器可能会在检测到错误之前转发不完整的消息。当响应不依赖于请求的其余部分是否正确时，服务器可能会在接收整个请求之前生成最终响应。

这些要求设计严格，旨在防止针对HTTP的几种常见攻击，因为宽松的协议可能会使实现暴露于这些漏洞。

## 8.2 HTTP字段
HTTP字段（[HTTP]的第5节）由HTTP/2在HEADERS、CONTINUATION和PUSH_PROMISE帧中传输，用HPACK[COMPRESSION]压缩。

在构造HTTP/2消息时，字段名必须转换为小写。

### 8.2.1 字段有效性
HTTP协议中禁止字段名和值中出现的字符，HPACK可能传递这些字符。实现HTTP/2协议的实例应分别根据[HTTP]第5.1节和第5.5节中的定义验证字段名和值中的字符，并将包含禁止字符的消息视为格式错误（第8.1.1节）。

未被验证的字段可能会被用于攻击。特别是，当使用HTTP/1.1[HTTP/1.1]转发消息时，未验证的字段可能会启用攻击，其中回车符（CR）、换行符（LF）和COLON等字符用作分隔符。实例必须对字段名和值执行以下最低限度的验证：

字段名不得包含0x00-0x20、0x41-0x5a或0x7f-0xff范围内的字符（包括所有范围）。这明确排除了所有不可见的ASCII字符、ASCII SP（0x20）和大写字符（'A'到'Z'，ASCII 0x41到0x5a）。

除了伪头部字段（第8.3节）的名称以单个冒号开头外，字段名称不得包含冒号（ASCII colon，0x3a）。

字段值在任何位置都不得包含零值（ASCII NUL，0x00）、换行符（ASCII LF，0x0a）或回车符（ASCII CR，0x0d）。

字段值不得以ASCII空白字符（ASCII SP或HTAB，0x20或0x09）开头或结尾。

注意：根据[HTTP]第5.1节和第5.5节中的定义的字段的有效性只需要额外检查字段名是否不包含大写字符。

头部字段名称包含违反上述条件的请求或响应必须被视为格式错误（第8.1.1节）。特别是，在转发消息时不处理字段的中间设备/服务器不得转发包含上述禁止的任何值的字段。

当请求消息违反这些要求之一时，实例应该生成一个400（错误请求）状态代码（见[HTTP]第15.5.1节），除非定义了更合适的状态代码或无法发送状态代码（例如，如果错误发生在尾部字段中）。

注意：根据相应字段的定义，无效的头部字段值不会导致请求格式错误；上述要求仅适用于[HTTP]第5节中定义的字段的通用语法。

### 8.2.2 连接相关的头部字段
HTTP/2不使用Connection头字段（[HTTP]第7.6.1节）来指示特定于连接的头字段；在该协议中，特定于连接的元数据通过其他方式传递。端点不得生成包含连接特定标头字段的HTTP/2消息。这包括Connection标头字段和[HTTP]第7.6.1节中列出的具有连接特定语义的字段（如，Proxy-Connection、Keep-Alive、Transfer-Encoding和Upgrade字段）。任何包含和连接相关的标头字段的消息都必须被视为格式错误（第8.1.1节）。

唯一的例外是TE标头字段，它可能存在于HTTP/2请求中；但它不得包含除“trailers”以外的任何值。

将HTTP/1.x消息转换为HTTP/2的中间服务器必须删除[HTTP]第7.6.1节中讨论的连接相关的标头字段，否则这些请求将被其他HTTP/2端点视为格式错误（第8.1.1节）。

注意：HTTP/2有意不支持升级到其他协议。第3节中描述的握手方法可以用来协商使用替代协议。

### 8.2.3 压缩Cookie头部字段
Cookie头字段使用分号（“；”）来分隔Cookie对（或“crumbs”）。此标头字段包含多个值，但不使用COMMA（“，”）作为分隔符，从而防止cookie对在多个字段行上发送（参见[HTTP]的第5.2节）。这会显著降低压缩效率，因为对单个cookie对的更新会使存储在HPACK表中的任何字段行无效。

为了提高压缩效率，Cookie头字段可能被拆分为单独的头字段，每个字段都有一个或多个Cookie对。如果解压缩后有多个Cookie头字段，则必须使用0x3b、0x20（ASCII字符串“；”）这两个字节的分隔符将其连接成一个字符串，然后再传递到非HTTP/2上下文中，如HTTP/1.1连接或通用HTTP服务器应用程序。

因此，以下两个Cookie头字段列表在语义上是等效的。

cookie: a=b; c=d; e=f

cookie: a=b
cookie: c=d
cookie: e=f

## 8.3 HTTP控制数据
HTTP/2使用以“：”字符（ASCII 0x3a）开头的特殊伪标头字段来传达消息控制数据（见[HTTP]的第6.2节）。

伪标头字段不是HTTP标头字段。端点不得生成除本文档中定义的字段之外的伪标头字段。请注意，扩展可以协商使用额外的伪标头字段；见第5.5节。

伪标头字段仅在定义它们的上下文中有效。为请求定义的伪标头字段不得出现在响应中；为响应定义的伪标头字段不得出现在请求中。伪标头字段不得出现在尾部字段。端点必须将包含未定义或无效伪标头字段的请求或响应视为格式错误（第8.1.1节）。

所有伪标头字段必须出现在所有常规字段行之前的字段块中。任何包含出现在常规字段行之后的字段块中的伪标头字段的请求或响应都必须被视为格式错误（第8.1.1节）。

同一伪标头字段名不得在字段块中出现多次。包含重复伪标头字段名的HTTP请求或响应的字段块必须被视为格式错误（第8.1.1节）。

### 8.3.1 请求中的伪标头字段
为HTTP/2请求定义了以下伪标头字段：

“:method”伪标头字段包括HTTP方法（[HTTP]第9节）。

“:scheme”伪标头字段包括请求的scheme部分。当直接生成请求时，字段取值为目标URI（[RFC3986]的第3.1节），或者从请求中获得（例如，参见[HTTP/1.1]的第3.3节）。CONNECT请求省略了scheme（第8.5节）。

“:scheme”取值不限于“http”和“https”。代理或网关可以转换非http的请求，从而使用http与非http服务进行交互。

“:authority”伪标头字段表示目标URI（[HTTP]第7.1节）的权限信息（[RFC3986]第3.2节）。如果存在“:authority”，则HTTP/2请求的接收者不得使用Host标头字段来确定目标URI。

  直接生成HTTP/2请求的客户端如果有权限信息需要发送，必须使用“:authority”伪标头字段来表示（在这种情况下，它不得生成“：authorities”）。

  客户端不能生成与“:authority”伪标头字段不同的Host标头字段的请求。如果请求包含一个Host标头字段，该字段标识的实体与“:authority”伪标头字段中的实体不同，则服务器应将其视为格式错误。字段的值可以使用任何规范化方法进行比较（见[RFC3986]的第6.2节）。源服务器可以应用任何规范化方法，而其他服务器必须对这两个字段按照RFC中定义的规范化方法进行处理（见[RFC3986]第6.2.3节）。

  需要生成Host标头字段的中间服务器（这可能是构造HTTP/1.1请求所必需的）必须使用“:authority”伪标头字段的值作为Host字段的值，除非中间设备更改了请求目标。使用“:authority”伪标头字段的值替换任何现有的Host字段，以避免HTTP路由中的潜在漏洞。

  转发HTTP/2请求的中间服务器可以保留任何Host标头字段。

  请注意，CONNECT或星号形式的OPTIONS请求的请求目标不包含权限信息；参见[HTTP]第7.1节和第7.2节。

  “:authority”一定不能包含“http”或“https”URI中已经弃用的用户信息。

“:path”伪标头字段包括目标URI的路径和参数部分（绝对路径，以及可选的“？”字符后面的参数；请参阅[HTTP]的第4.1节）。OPTIONS请求的“:path”伪标头字段的值为“*”。

  对于“http”或“https”URI，“:path”伪标头字段不得为空，如果没有URI信息，则“http”或“https”URI取值为“/”。有以下例外情况：

  OPTIONS请求不包含“http”或“https”URI信息，此时“:path”伪标头字段取值为“*”（见[HTTP]的第7.1节）。

  CONNECT请求（第8.5节）不包含“:path”伪标头字段。

除了CONNECT请求（第8.5节），所有HTTP/2请求必须有且仅有一个“:method”、“:scheme”和“:path”伪标头字段。省略必须的伪标头字段的HTTP请求被认为格式错误（第8.1.1节）。

单个HTTP/2请求不携带协议版本信息。所有HTTP/2请求都隐式地具有“2.0”的协议版本（参见[HTTP]的第6.2节）。

### 8.3.2 响应中的伪头部字段
对于HTTP/2响应，定义了一个“:status”伪标头字段，其中包含HTTP状态码（见[HTTP]的第15节）。此伪标头字段必须包含在所有响应中，包括临时响应；否则，响应格式错误（第8.1.1节）。

HTTP/2响应隐式地具有“2.0”的协议版本。

## 8.4 服务端推送
HTTP/2允许服务器抢先向客户端发送（或“推送”）响应（以及相应的“承诺”请求），并与之前客户端发起的请求相关联。

服务器推送旨在通过预测已经接收到的请求之后会有什么请求，从而避免客户端再次发送请求这样一个网络往返，提高客户端的性能。例如，对HTML的请求后通常还需要请求该页面引用的样式表和脚本。当这些请求被推送时，客户端不需要等待HTML中对它们的引用并发出单独的请求。

在实践中，服务器推送很难有效使用，因为它要求服务器正确预测客户端将发出的额外请求，同时考虑到缓存、内容协商和用户行为等因素。由于线路上的额外数据所代表的机会成本，预测中的错误可能会导致性能下降。特别是，推送任何大量数据都可能导致与更重要的响应的争用问题。

客户端可以请求禁用服务器推送，尽管这是每一跳独立协商的。SETTINGS_ENABLE_PUSH设置可以设置为0，表示服务器推送被禁用。

承诺的请求必须是安全的（见[HTTP]第9.2.1节）和可缓存的（见[HTTP]第9.2.3节）。承诺的请求不能包含请求体或尾部字段部分。收到不可缓存、不安全或包含请求体的承诺请求的客户端必须使用PROTOCOL_ERROR类型的流错误（第5.4.2节）重置承诺流。请注意，如果客户端不认为新定义的方法是安全的，这可能会导致所承诺的流被重置。

如果客户端实现了HTTP缓存，则可以存储可缓存的推送响应（见[CACHING]的第3节）。当承诺的流标识符标识的流仍处于打开状态，推送响应被认为在源服务器上已成功验证。（例如，响应中可以包含“no-cache”信息，则客户端不对响应体进行缓存；请参阅[CACHING]的第5.2.2.4节）

不可缓存的推送响应不得由任何HTTP缓存存储。它们可以单独提供给应用程序。

如果服务器需要进行认证的话，服务器必须在“:authority”伪标头字段中包含权限信息（见第10.1节）。客户端必须将服务器发送的没有包含权限信息的PUSH_PROMISE视为协议错误类型的流错误（第5.4.2节）。

中间服务器可以从服务器接收推送，并选择不将其转发给客户端。换句话说，如何利用推送的信息取决于中间服务器。同样，中间服务器可能会选择向客户端进行额外的推送，而无需服务器采取任何行动。

客户端无法推送。因此，服务器必须将PUSH_PROMISE帧的接收视为协议错误类型的连接错误（第5.4.1节）。服务器不能将SETTINGS_ENABLE_PUSH设置为0以外的值（见第6.5.2节）。

### 8.4.1 推送请求
服务器推送在语义上等同于服务器对请求的响应；然而，在这种情况下，该请求也由服务器作为PUSH_PROMISE帧发送。

PUSH_PROMISE帧包括一个字段块，其中包含控制数据和一组完整的请求头字段，服务器将这些字段视为请求。服务器无法推送对包含消息内容的请求的响应。

承诺的请求总是与来自客户端的显式请求相关联。服务器发送的PUSH_PROMISE帧在显式请求的流上发送。PUSH_PROMISE帧还包括从服务器可用的流标识符中选择的承诺流标识符（见第5.1.1节）。

客户端请求 → 服务端发送 PUSH_PROMISE → 服务端发送父响应的 HEADERS 和 DATA 帧 → 服务端在独立流中发送推送资源的 HEADERS 和 DATA 帧

PUSH_PROMISE和任何后续CONTINUATION帧中的标头字段必须是一组有效且完整的请求标头字段（第8.3.1节）。服务器必须在“:method”伪标头字段中包含一个安全且可缓存的方法。如果客户端收到的PUSH_PROMISE不包括一组完整有效的标头字段，或者“:method”伪标头字段标识了一个不安全的方法，则它必须在承诺的流上返回PROTOCOL_ERROR类型的流错误（第5.4.2节）。

服务器应在发送任何引用承诺响应的帧之前发送PUSH_PROMISE（第6.6节）帧。这避免了客户端在接收任何PUSH_PROMISE帧之前发出请求的竞争。

例如，如果服务器收到对包含多个图像文件的嵌入式链接的文档的请求，并且服务器选择将这些附加图像推送到客户端，则在包含图像链接的DATA帧之前发送PUSH_PROMISE帧，以确保客户端能够在发现嵌入式链接之前看到资源将被推送。同样，如果服务器推送字段块引用的资源（例如，在链路报头字段中），在发送报头之前发送PUSH_PROMISE帧可确保客户端不会请求这些资源。

客户端一定不能发送PUSH_PROMISE帧。

PUSH_PROMISE帧可以由服务器在任何客户端发起的流上发送，但对于服务器而言，流必须相“打开”或“半关闭（远程）”状态。PUSH_PROMISE帧与包含响应的帧穿插在一起，尽管它们不能与包含单个字段块的HEADERS和CONTINUATION帧穿插。

发送PUSH_PROMISE帧会创建一个新流，并将该流置于服务器的“保留（本地）”状态和客户端的“保留的（远程）”状态。

### 8.4.2 推送响应
在发送PUSH_PROMISE帧后，服务器可以开始在使用承诺流标识符的流上推送响应（第8.3.2节）。服务器使用此流传输HTTP响应，使用与第8.1节中定义的帧序列相同的帧序列。在发送初始HEADERS帧后，该流对客户端是“半关闭（远端）”状态（第5.1节）。服务端推送响应的流中，客户端认为此流是“半关闭（远端）”状态，即客户端在此流上不发送信息。

一旦客户端收到PUSH_PROMISE帧并选择接受推送的响应，客户端就不应该发出任何对承诺响应的请求，直到承诺流关闭。

如果客户端出于任何原因确定它不希望从服务器接收推送的响应，或者如果服务器开始发送承诺的响应花费了太长时间，客户端可以使用CANCEL帧或REFUSED_STREAM错误码并引用推送流的标识符来发送RST_STREAM帧。

客户端可以使用SETTINGS_MAX_CONCURRENT_STREAMS设置来限制服务器可以同时推送的响应数量。通告SETTINGS_MAX_CONCURRENT_STREAMS值为零会阻止服务器打开推送响应所需的流。然而，这并不能阻止服务器使用PUSH_PROMISE帧保留流，因为保留的流不计入并发流限制。不希望接收推送资源的客户端需要重置任何不需要的保留流或将SETTINGS_ENABLE_PUSH设置为0。

收到推送响应的客户端必须验证服务器是否具有权威性（见第10.1节），或者验证提供推送响应的代理服务器是否针对相应的请求进行了配置。例如，只为example.com DNS-ID（见[RFC6125]）提供证书的服务器不允许推送这个URI请求<https://www.example.org/doc>的响应。

PUSH_PROMISE流的响应以HEADERS帧开始，该帧立即将流置于服务器的“半封闭（远程）”状态和客户端的“半关闭（本地）”状态，并以设置了END_STREAM标识的帧结束，该帧将流置于“关闭”状态。

注意：客户端从不发送为服务器推送设置了END_STREAM标识的帧。

## 8.5 CONNECT方法
CONNECT方法（[HTTP]第9.3.6节）用于将HTTP连接转换为到远程主机的隧道。CONNECT主要与HTTP代理一起使用，与源服务器建立TLS会话，以便与“https”资源进行交互。

在HTTP/2中，CONNECT方法通过单个HTTP/2流建立到远程主机的隧道，而不是将整个连接转换为隧道。CONNECT标头部分的构造如第8.3.1节（“请求伪标头字段”）所述，但有一些差异。明确地：

“:method”伪标头字段设置为CONNECT。
“:scheme”和“:path”伪标头字段必须省略。
“:authority”伪标头字段包含要连接的主机和端口（相当于CONNECT请求的请求目标的authority形式；请参阅[HTTP/1.1]的第3.2.3节）。

不符合这些限制的CONNECT请求被认定为格式错误（第8.1.1节）。

支持CONNECT的代理与“:authority”伪标头字段中标识的主机和端口建立TCP连接[TCP]。一旦成功建立此连接，代理就会向客户端发送一个包含2xx系列状态码的HEADERS帧，如[HTTP]第9.3.6节所定义。

在每个端点发送初始HEADERS帧之后，所有后续的DATA帧都对应于TCP连接上发送的数据。客户端发送的任何DATA帧的帧有效载荷由代理传输到TCP服务器；从TCP服务器接收到的数据由代理组装成DATA帧发送给服务端。除数据或流管理帧（RST_STREAM、WINDOW_UPDATE和PRIORITY）之外的帧类型不得在连接的流上发送，如果收到，必须被视为流错误（第5.4.2节）。

TCP连接可以由任何端点关闭。DATA帧上的END_STREAM标识被视为等同于TCP FIN位。客户端在收到设置了END_STREAM标识的帧后，应发送设置了END_STREAM标识的DATA帧。接收带有END_STREAM标识的DATA帧的代理发送带有最后一个TCP段上设置的FIN位的附加数据。接收具有FIN位的TCP段的代理发送具有END_STREAM标识的DATA帧。请注意，最后的TCP段或DATA帧可能为空。

TCP连接错误用RST_STREAM发出信号。代理将TCP连接中的任何错误（包括接收具有RST位的TCP段）视为CONNECT_ERROR类型的流错误（第5.4.2节）。相应地，如果代理检测到流或HTTP/2连接出错，则必须发送一个设置了RST位的TCP段。TCP连接已经有错误，还如何发送RST_STREAM帧呢？

## 8.6 Upgrade头部
HTTP/2不支持101（交换协议）信息状态码（[HTTP]第15.2.2节）。

101（交换协议）的语义不适用于多路复用协议。通过使用扩展的CONNECT[RFC8441]可以启用类似的功能，其他协议也可以使用HTTP/2协商出其使用的机制（见第3节）。

## 8.7 请求可靠性
一般来说，当发生错误时，HTTP客户端无法重试非幂等请求，因为无法确定错误的性质（见[HTTP]第9.2.2节）。可能在错误发生之前发生了服务器做了一些处理，如果重新尝试请求，可能会导致无法预料的影响。

HTTP/2提供了两种机制可以向客户端表明服务端没有处理哪些请求：

GOAWAY帧表示可能已处理的流的最高数值标识符。因此，在具有较高数值流标识符的流上的请求可以安全地重试。

RST_STREAM帧中的REFUSED_STREAM错误代码表示流在哪些处理发生之前已被关闭。在重置流上发送的任何请求都可以安全地重试。

尚未处理的请求可能没有失败；客户端可能会自动重试它们，即使那些是非幂等请求。

服务器如果不能保证流是否被处理，一定不能表明流尚未处理。如果流上的帧被传递给任何流的应用层（？），则REFUSED_STREAM错误码不得用于该流，GOAWAY帧必须包含大于或等于给定流标识符的流标识符。

除了这些机制之外，PING帧还为客户端提供了一种轻松测试连接的方法。保持空闲的连接可能会中断，因为一些中间设备（例如，网络地址转换器或负载均衡器）会默默地断开TCP连接。PING帧允许客户端在不发送请求的情况下安全地测试连接是否仍然处于活动状态。

## 8.8 举例
本节举例说明HTTP/1.1请求和响应，并附有等效HTTP/2请求和响应的说明。

### 8.8.1 简单请求
HTTP GET请求包括控制数据和没有消息内容的请求头，因此作为单个HEADERS帧传输，后面是零个或多个包含序列化请求头字段块的CONTINUATION帧。下面的HEADERS帧同时设置了END_HEADERS和END_STREAM标志，没有CONTINUATION帧。
```
  GET /resource HTTP/1.1           HEADERS
  Host: example.org              ==>  + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                               :method = GET
                               :scheme = https
                               :authority = example.org
                               :path = /resource
                                host = example.org
                                accept = image/jpeg
```
### 8.8.2 简单响应
类似地，简单响应仅包括控制数据和响应报头，通过包含串行化响应报头字段块的HEADERS帧（同样，后面是零个或多个CONTINUATION帧）传输。
```
HTTP/1.1 304 Not Modified            HEADERS
  ETag: "xyzzy"                ==>    + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                :status = 304
                                etag = "xyzzy"
                                expires = Thu, 23 Jan ...
```
一个请求是一个完整的流，一个响应是一个完整的流，请求流和响应流通过相同的流标识符进行一一对应。只是客户端新发起的流的流标识符是奇数，服务端新发起的流的流标识是偶数，注意并不是服务端对客户端的响应的流标识符也是偶数。

### 8.8.3 复杂请求
HTTP POST请求包含控制数据和请求体，通过一个HEADERS帧的形式传输，后面是零个或多个包含请求头的CONTINUATION帧，然后是一个或多个子数据帧，最后一个CONTINUATION（或HEADERS）帧设置了END_HEADERS标识，最后一个子数据帧设置了END_STREAM标识。
```
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>    - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                :method = POST
                               :authority = example.org
                               :path = /resource
  {binary data}                    :scheme = https

                               CONTINUATION
                                 + END_HEADERS
                               content-type = image/jpeg
                               host = example.org
                               content-length = 123

                               DATA
                                 + END_STREAM
                               {binary data}
```

请注意，对任何给定字段行有用的数据都可以在字段块段之间传播。在这个例子中，仅将字段行作为帧的内容进行发送只是为了说明HTTP/1.1中的语义是如何在HTTP/2中体现的。

### 8.8.4 包含响应体的响应
包含控制数据和响应体的响应以HEADERS帧的形式传输，后面是零个或多个CONTINUATION帧，然后是一个或多个子数据帧，序列中的最后一个数据帧设置了END_STREAM标识。
```
  HTTP/1.1 200 OK                   HEADERS
  Content-Type: image/jpeg     ==>       - END_STREAM
  Content-Length: 123                  + END_HEADERS
                                :status = 200
 {binary data}                      content-type = image/jpeg
                                content-length = 123

                                DATA
                                 + END_STREAM
                                {binary data}
```
### 8.8.5 信息响应
使用除101之外的1xx状态码的信息响应作为HEADERS帧传输，后面是零个或多个CONTINUATION帧。

在请求或响应字段块和所有DATA帧都已发送后，将尾部作为字段块发送。包含尾部字段的字段块开始的HEADERS帧设置了END_STREAM标志。

以下示例包括一个100（Continue）状态代码和一个尾部字段，该代码是响应Expect标头字段取值为“100-Continue”的请求而发送的：

```
HTTP/1.1 100 Continue            HEADERS
Extension-Field: bar      ==>          - END_STREAM
                               + END_HEADERS
                              :status = 100
                              extension-field = bar

HTTP/1.1 200 OK                    HEADERS
Content-Type: image/jpeg   ==>         - END_STREAM
Transfer-Encoding: chunked              + END_HEADERS
Trailer: Foo                      :status = 200
                              content-type = image/jpeg
123                            trailer = Foo
{binary data}
0                             DATA
Foo: bar                          - END_STREAM
                             {binary data}

                              HEADERS
                               + END_STREAM
                               + END_HEADERS
                              foo = bar
```
# 9 HTTP/2连接
HTTP/2连接是长连接。为了获得最佳性能，建议客户端在确定是否需要与服务器进行进一步通信之前（例如，当用户离开特定网页时）或在服务器关闭连接之前不会关闭连接。

客户端不应该向给定的主机IP和端口号打开多个HTTP/2连接，其中主机来自URI、选定的替代服务[ALT-SVC]或配置的代理。

客户端可以创建额外的连接替代接近耗尽可用流标识符空间的连接（第5.1.1节）、刷新TLS连接的秘钥，或替代遇到错误的连接（第5.4.1节）。

客户端可以使用不同的服务器名称指示，即SNI[TLS-EXT]值打开到同一IP地址和TCP端口的多个连接，或者提供不同的TLS客户端证书，但应避免使用相同的配置创建多个连接。

鼓励服务器尽可能长时间地保持连接，但必要时允许终止空闲连接。当任一端点选择关闭传输层TCP连接时，终止端点应首先发送GOAWAY（第6.8节）帧，以便两个端点都能可靠地确定之前发送的帧是否已被处理，并优雅地完成或终止任何必要的剩余任务。

### 9.1.1 连接复用
直接或通过CONNECT方法创建隧道（第8.5节）的方式与源服务器建立的连接可以用于多个不同URI的请求。只要源服务器是经过认证的，就可以复用连接（第10.1节）。对于没有TLS的TCP连接，这取决于主机是否解析到相同的IP地址。

对于“https”资源，连接复用还取决于对URI中指定的主机有效的证书。服务器提供的证书必须满足客户端在URI中指定的主机建立新的TLS连接时执行的任何检查。单个证书可用于为多个来源建立授权。[HTTP]的第4.3节描述了客户端如何确定服务器是否对URI具有权威性。客户端判断证书的有效性

在某些部署中，在多个目的服务器之间复用连接可能会导致请求被定向到错误的目标服务器。例如，TLS连接断开可能由中间设备或中间服务器根据TLS扩展中的SNI（Server Name Indication）选择的目标服务器执行。这意味着客户端可以向可能不是请求预期目标的服务器发送请求，即使服务器提供的证书是有效的。客户端发送的请求，服务端可能根据URI中的Host信息选择目标服务器，也可能通过ClientHello消息中的SNI字段选择目标服务器。

不希望客户端复用连接的服务器可以通过发送421（定位错误的请求）状态码来响应请求，从而表明它对请求没有权威性（见[HTTP]第15.5.20节）。

客户端被配置成通过单个连接将请求从一个代理服务器转发到另一个代理服务器。也就是说，通过代理发送的所有请求都会复用到另一个代理的连接。

## 9.2 TLS特性的使用
本节介绍用于HTTP/2的TLS 1.2功能集的限制。由于某些部署限制，当不满足这些限制时，TLS协商可能不会失败。但端点可能会立即终止不符合这些TLS要求的HTTP/2连接，并出现INADEQUATE_SECURITY类型的连接错误（第5.4.1节）。

在TLS 1.2上部署HTTP/2必须禁用压缩。TLS压缩可能导致信息泄露[RFC3749]。通用压缩是不必要的，因为HTTP/2提供了更了解上下文的压缩功能，因此可能更适合用于性能、安全或其他原因。

在TLS 1.2上部署HTTP/2必须禁用重新协商。端点必须将TLS重新协商视为协议错误类型的连接错误（第5.4.1节）。请注意，由于底层密码套件可以加密的消息数量的限制，禁用重新协商可能会导致长连接变得不可用。

端点可以使用重新协商为SSL握手中提供的客户端凭据提供机密性保护，但任何重新协商都必须在发送连接序言之前进行。如果服务器在建立连接后立即看到重新协商请求，则应请求客户端证书。

这有效地防止了对特定受保护资源的请求进行重新协商。未来的规范可能会提供一种支持此用例的方法。或者，服务器可能会使用HTTP_1_1_REQUIRED类型的错误（第5.4节）来请求客户端使用支持重新协商的协议。

对于使用临时有限字段Diffie-Hellman（DHE）的密码套件，实例必须支持至少2048位的临时密钥交换大小（[TLS12]第8.1.2节），对于使用临时椭圆曲线Diffie-Hell（ECDHE）的密码套件，实例必须支撑224位的临时密钥交换大小[RFC8422]。客户端必须接受高达4096位的DHE大小。端点可能会将小于下限的密钥大小的协商视为INADEQUATE_SECURITY类型的连接错误（第5.4.1节）。

### 9.2.2 TLS1.2加密套件
在TLS 1.2上部署HTTP/2不应使用附录A中列出的任何禁止使用的密码套件。

如果协商使用禁止的密码套件之一，端点可能会选择生成INADEQUATE_SECURITY类型的连接错误（第5.4.1节）。选择使用禁止的密码套件的部署可能会触发连接错误，除非已知所有潜在的端点接受该密码套件。

实例不得在协商使用未被禁止的密码套件时产生此错误。因此，当客户端提供未被禁止的密码套件时，他们必须准备将该密码套件与HTTP/2一起使用。

禁止的密码套件列表包括TLS 1.2强制使用的密码套件，这意味着TLS 1.2部署可能具有禁止使用的密码套件集。为了避免这个导致TLS握手失败的问题，使用TLS 1.2的HTTP/2部署必须支持具有P-256椭圆曲线[RFC8422]的TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256[TLS-ECDHE]。

请注意，客户端可能会支持禁止的密码套件，以便允许连接到不支持HTTP/2的服务器。这允许服务器使用HTTP/2中禁止的密码套件并选择HTTP/1.1进行通信。然而，如果独立选择应用协议和密码套件，这可能会导致HTTP/2与被禁止的密码套件进行协商。

### 9.2.3 TLS1.3特性
TLS 1.3包含许多早期版本中没有的功能。本节讨论这些功能的使用。

HTTP/2服务器不得发送握手后TLS 1.3证书请求消息。HTTP/2客户端必须将握手后的TLS CertificateRequest消息视为协议错误类型的连接错误（第5.4.1节）。

即使客户端提供了“post_handshake_auth”TLS扩展，握手后身份验证功能仍然禁用。握手后身份验证支持可能独立于ALPN[TLS-ALPN]。客户端可能提供在其他协议中使用的功能，但包含扩展并不意味着实现HTTP/2协议的实例也支持。

[TLS13]定义了其他握手后消息，NewSessionTicket和KeyUpdate可以使用，因为它们与HTTP/2没有直接交互。除非新型TLS消息的使用取决于与应用层协议的交互，否则可以在握手完成后发送该TLS消息。

TLS早期数据可用于发送请求，前提是遵守[RFC8470]协议。客户端在早期数据中发送请求时假设所有服务器设置的默认初始值。




















